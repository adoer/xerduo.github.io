{"meta":{"title":"小耳朵","subtitle":null,"description":null,"author":"Duer","url":"http://xerduo.com"},"pages":[{"title":"","date":"2021-03-05T13:58:59.927Z","updated":"2021-03-05T13:58:59.927Z","comments":true,"path":"google184e1e684149229c.html","permalink":"http://xerduo.com/google184e1e684149229c.html","excerpt":"","text":"google-site-verification: google184e1e684149229c.html"},{"title":"","date":"2018-01-19T06:58:08.000Z","updated":"2021-03-08T13:45:12.295Z","comments":true,"path":"about/index.html","permalink":"http://xerduo.com/about/index.html","excerpt":"","text":"关于我1234567&#123; \"name\": \"Duer\", \"Github\": \"https://github.com/adoer\", \"blog\": \"www.xerduo.com\", \"email\": \"duqingbetter@qq.com\", \"WeChat\": \"duerKing\",&#125;"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2021-03-05T13:58:59.925Z","comments":false,"path":"categories/index.html","permalink":"http://xerduo.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2021-03-05T13:58:59.928Z","comments":true,"path":"tags/index.html","permalink":"http://xerduo.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"call,apply,bind的用法区别解析","slug":"call,apply,bind的用法区别解析","date":"2021-06-26T09:05:46.000Z","updated":"2021-06-26T11:22:58.896Z","comments":true,"path":"2021/06/26/call,apply,bind的用法区别解析/","link":"","permalink":"http://xerduo.com/2021/06/26/call,apply,bind的用法区别解析/","excerpt":"call、apply、bind异同 由于call()、apply()与bind()都是属于Function.prototype对象下的方法，所以每个function实例都拥有有call、apply与bind属性。 相同点：都是为改变this指向而存在的。 异同点：使用call()方法时，传递给函数的参数必须逐个列举出来，使用apply()方法时，传递给函数的是参数数组。bind()和call()很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。bind()方法不会立即执行，而是返回一个改变了上下文 this后的函数，用于稍后调用。 call()、apply()则是立即调用。","text":"call、apply、bind异同 由于call()、apply()与bind()都是属于Function.prototype对象下的方法，所以每个function实例都拥有有call、apply与bind属性。 相同点：都是为改变this指向而存在的。 异同点：使用call()方法时，传递给函数的参数必须逐个列举出来，使用apply()方法时，传递给函数的是参数数组。bind()和call()很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。bind()方法不会立即执行，而是返回一个改变了上下文 this后的函数，用于稍后调用。 call()、apply()则是立即调用。 这里的this指向window对象 1234funciton foo () &#123; console.log(this); // window对象&#125;foo() // window对象 这里的this指向调用者，谁调用this就指向谁 1234567891011var name = '王小二'var obj = &#123; age:20, name:'张小二', foo:function () &#123; console.log(this.age + '---' + this.name) &#125;&#125;obj.foo() // 20---张小二var fun = obj.foofun() // undefined---王小二 使用call()、apply()、bind()改变this的上下文： 123456789101112let name = '张小二'function foo(sex,age)&#123; console.log(`$&#123;this.name&#125;---$&#123;sex&#125;---$&#123;age&#125;`)&#125;let obj = &#123; name : '王小二'&#125;foo('男',18) // 张小二---男---18foo.call(obj,'男',18) // 王小二---男---18foo.apply(obj,['男',18]) // 王小二---男---18foo.bind(obj,'男',18)() // 王小二---男---18","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JavaScript中的new操作符的原理解析","slug":"JavaScript中的new操作符的原理解析","date":"2021-06-25T15:05:12.000Z","updated":"2021-06-26T11:31:14.358Z","comments":true,"path":"2021/06/25/JavaScript中的new操作符的原理解析/","link":"","permalink":"http://xerduo.com/2021/06/25/JavaScript中的new操作符的原理解析/","excerpt":"JavaScript中的new操作符的原理解析JavaScript中new操作符用于创建一个给定构造函数的对象实例。如下例子： 123456function Person(name, age)&#123; this.name = name; this.age = age;&#125;const person1 = new Person('Tom', 20)console.log(person1) // Person &#123;name: \"Tom\", age: 20&#125; 我们定义了一个构造函数Person，然后通过new操作符生成Person构造函数的一个实例并将其引用赋值给变量person1。然后控制台打印出person1的内容，可以看到该实例对象具有name和age属性，它们的值就是我们在调用构造函数时传入的值。 那么，我们使用new操作符的时候都发生了哪些事呢？ new关键字进行的操作new关键字进行了如下的操作（为了便于描述，obj用来表示创建的空对象、用constrc来表示构造函数）： 1、创建一个空对象obj（{}）；2、将obj的[[prototype]]属性指向构造函数constrc的原型（即obj.[[prototype]] = constrc.prototype）。3、将构造函数constrc内部的this绑定到新建的对象obj，执行constrc（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.constrc()一样）；4、若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象obj（默认会添加return this）。否则，返回引用类型的值。这里补充说明一下：[[prototype]]属性是隐藏的，不过目前大部分新浏览器实现方式是使用proto来表示。构造函数的prototype属性我们是可以显式访问的。","text":"JavaScript中的new操作符的原理解析JavaScript中new操作符用于创建一个给定构造函数的对象实例。如下例子： 123456function Person(name, age)&#123; this.name = name; this.age = age;&#125;const person1 = new Person('Tom', 20)console.log(person1) // Person &#123;name: \"Tom\", age: 20&#125; 我们定义了一个构造函数Person，然后通过new操作符生成Person构造函数的一个实例并将其引用赋值给变量person1。然后控制台打印出person1的内容，可以看到该实例对象具有name和age属性，它们的值就是我们在调用构造函数时传入的值。 那么，我们使用new操作符的时候都发生了哪些事呢？ new关键字进行的操作new关键字进行了如下的操作（为了便于描述，obj用来表示创建的空对象、用constrc来表示构造函数）： 1、创建一个空对象obj（{}）；2、将obj的[[prototype]]属性指向构造函数constrc的原型（即obj.[[prototype]] = constrc.prototype）。3、将构造函数constrc内部的this绑定到新建的对象obj，执行constrc（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.constrc()一样）；4、若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象obj（默认会添加return this）。否则，返回引用类型的值。这里补充说明一下：[[prototype]]属性是隐藏的，不过目前大部分新浏览器实现方式是使用proto来表示。构造函数的prototype属性我们是可以显式访问的。让我们用图来展示文章开头的那个例子的过程： ; 自己实现new操作符1234567891011121314151617function myNew(constrc, ...args) &#123; // 1,2 创建一个对象obj，将obj的[[prototype]]属性指向构造函数的原型对象 // 即实现：obj.__proto__ === constructor.prototype const obj = Object.create(constrc.prototype) // 3.将constrc内部的this（即执行上下文）指向obj，并执行 const result = constrc.apply(obj, args); // 4. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象 return result instanceof Object ? result : obj; &#125;// 使用的例子：function Person(name, age)&#123; this.name = name; this.age = age;&#125;const person1 = myNew(Person, 'Tom', 20)console.log(person1) // Person &#123;name: \"Tom\", age: 20&#125; 这里的关键两步就是： 1、将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。2、将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS原型与原型链","slug":"JS原型与原型链","date":"2021-06-20T15:19:26.000Z","updated":"2021-06-26T15:54:37.425Z","comments":true,"path":"2021/06/20/JS原型与原型链/","link":"","permalink":"http://xerduo.com/2021/06/20/JS原型与原型链/","excerpt":"原型和原型链这几个要点是理解原型的关键：1、所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）。2、所有的引用类型都有一个’_ _ proto_ _ ‘属性(也叫隐式原型，它是一个普通的对象)。3、所有的函数都有一个’prototype’属性(这也叫显式原型，它也是一个普通的对象)。4、所有引用类型，它的’_ _ proto_ _’属性指向它的构造函数的’prototype’属性。5、当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _’属性(也就是它的构造函数的’prototype’属性)中去寻找。 原型构造函数的属性prototype,叫做原型,这是可以直接使用的。在JS实例对象中有一个属性 __proto__ ,它也是原型,这是供浏览器使用的,它不是标准的属性。(实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为__proto__)。 实例对象中的__proto__指向的是该实例对象中的构造函数中的prototype，构造函数中的prototype里面的属性或者方法,可以直接通过实例对象调用。 示例： 12function Foo() &#123;...&#125;; // 申明构造函数Fooconsole.log( Foo.prototype ); // 打印其prototype属性 控制台输出 123456789101112&#123; constructor: ƒ Foo(), __proto__: &#123; constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125;&#125; 上面这个对象，就是常说的原型对象可以看到，原型对象有一个自有属性constructor，这个属性指向该函数 1Foo.prototype.constructor === Foo // true 原型对象也是一个普通对象，属性__proto__指向其构造函数的原型。1Foo.prototype.__proto__ === Object.prototype // true 原型链","text":"原型和原型链这几个要点是理解原型的关键：1、所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）。2、所有的引用类型都有一个’_ _ proto_ _ ‘属性(也叫隐式原型，它是一个普通的对象)。3、所有的函数都有一个’prototype’属性(这也叫显式原型，它也是一个普通的对象)。4、所有引用类型，它的’_ _ proto_ _’属性指向它的构造函数的’prototype’属性。5、当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _’属性(也就是它的构造函数的’prototype’属性)中去寻找。 原型构造函数的属性prototype,叫做原型,这是可以直接使用的。在JS实例对象中有一个属性 __proto__ ,它也是原型,这是供浏览器使用的,它不是标准的属性。(实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为__proto__)。 实例对象中的__proto__指向的是该实例对象中的构造函数中的prototype，构造函数中的prototype里面的属性或者方法,可以直接通过实例对象调用。 示例： 12function Foo() &#123;...&#125;; // 申明构造函数Fooconsole.log( Foo.prototype ); // 打印其prototype属性 控制台输出 123456789101112&#123; constructor: ƒ Foo(), __proto__: &#123; constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125;&#125; 上面这个对象，就是常说的原型对象可以看到，原型对象有一个自有属性constructor，这个属性指向该函数 1Foo.prototype.constructor === Foo // true 原型对象也是一个普通对象，属性__proto__指向其构造函数的原型。1Foo.prototype.__proto__ === Object.prototype // true 原型链","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"避坑,fill初始化多维数组","slug":"避坑,fill初始化多维数组","date":"2021-05-18T14:39:17.000Z","updated":"2021-06-20T15:19:48.499Z","comments":true,"path":"2021/05/18/避坑,fill初始化多维数组/","link":"","permalink":"http://xerduo.com/2021/05/18/避坑,fill初始化多维数组/","excerpt":"避坑,fill初始化多维数组数组实例的 fill(),使用给定值，填充一个数组。例如： 12let a = new Array(5).fill(0);console.log(a); // 输出结果为[0, 0, 0, 0, 0] 使用fill()创建二维数组12let arr=new Array(3).fill(new Array(3).fill(0))console.log(arr); // 输出结果为[[0,0,0],[0,0,0],[0,0,0]]","text":"避坑,fill初始化多维数组数组实例的 fill(),使用给定值，填充一个数组。例如： 12let a = new Array(5).fill(0);console.log(a); // 输出结果为[0, 0, 0, 0, 0] 使用fill()创建二维数组12let arr=new Array(3).fill(new Array(3).fill(0))console.log(arr); // 输出结果为[[0,0,0],[0,0,0],[0,0,0]] 看似没问题，当给某个元素赋值时如下：每个第一行每一列1的元素的值都改变了。12arr[1][1]=1;console.log(arr) // 输出结果为[[0,1,0],[0,1,0],[0,1,0]] 原因 fill()的参数不是基本类型时，好比数组、对象，并非将它的值填充到数组，而是将它的地址填充到数组，因此填充后数组的每一项都指向的是同一个对象，就会出现”牵一发而动全身”的现象。 解决方法可以使用map遍历123let arr=new Array(3).fill(0).map(item=&gt;new Array(3).fill(0))arr[1][1]=1console.log(arr); // 输出结果为[[0,0,0],[0,1,0],[0,0,0]] 这样就只有arr[1][1]发生改变了。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"forEach、for in 、 for of三者的区别","slug":"forEach,for in,for of三者区别","date":"2021-04-10T02:12:22.000Z","updated":"2021-04-10T03:43:51.996Z","comments":true,"path":"2021/04/10/forEach,for in,for of三者区别/","link":"","permalink":"http://xerduo.com/2021/04/10/forEach,for in,for of三者区别/","excerpt":"for循环除了这三种方法以外还有一种最原始的遍历，它用来遍历数组，for循环中可以使用return、break等来中断循环。","text":"for循环除了这三种方法以外还有一种最原始的遍历，它用来遍历数组，for循环中可以使用return、break等来中断循环。 123456789let arr = [1,2,3]for(let i = 0 ; i&lt; arr.length ; i++)&#123; console.log(arr[i])&#125;/* 输出结果123*/ forEach 对数组的每一个元素执行一次提供的函数（不能使用return、break等中断循环），不改变原数组，无返回值undefined。 123456789let arr = ['a', 'b', 'c']arr.forEach(function (val, index, arr) &#123; // val是当前元素，index当前元素索引，arr数组 console.log(val + ',' + index)&#125;)/* 输出结果a,0b,1c,2*/ for…in循环遍历的值都是数据结构的键值12345let obj = &#123;a: '1', b: '2', c: '3'&#125;for (let o in obj) &#123; console.log(o) //遍历的实际上是对象的属性名称 a,b,c console.log(obj[o]) //这个才是属性对应的值1，2，3&#125; for…in循环有几个缺点。 1、数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。2、for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。12345678910111213Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;;var arr = [3, 5];arr.foo = 'hello';for (var i in arr) &#123; console.log(i);&#125;// 结果是：// 0// 1// foo// arrCustom// objCustom 3、某些情况下，for…in循环会以任意顺序遍历键名。（先把当中的非负整数键提出来，排序好输出，然后将剩下的定义时的顺序输出）4、不可以使用return、break等来中断循环 总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。 for…ofES6中新增加的语法，用来循环获取一对键值对中的值，可以使用return、break等来中断循环 一个数据结构只有部署了 Symbol.iterator 属性, 才具有 iterator接口可以使用 for of循环。例子中的obj对象没有Symbol.iterator属性 所以会报错。 哪些数据结构部署了 Symbol.iteratoer属性了呢? 数组 ArrayMapSetStringarguments对象Nodelist对象, 就是获取的dom列表集合 循环一个数组1234let arr = ['China', 'America', 'Korea']for (let o of arr) &#123; console.log(o) //China, America, Korea&#125; 循环一个普通对象（报错） obj对象没有Symbol.iterator属性 所以会报错。 1234let obj = &#123;a: '1', b: '2', c: '3', d: '4'&#125;for (let o of obj) &#123; console.log(o) // Uncaught TypeError: obj is not iterabl&#125; 如果想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象的 key值集合后,再使用 for of，或者使用内置的Object.values()方法获取对象的value值集合再使用for of。 123456789let obj = &#123;a: '1', b: '2', c: '3', d: '4'&#125;for (let o of Object.keys(obj)) &#123; console.log(o) // a,b,c,d&#125;let obj = &#123;a: '1', b: '2', c: '3', d: '4'&#125;for (let o of Object.values(obj)) &#123; console.log(o) // 1,2,3,4&#125; 循环一个字符串 1234let str = 'love'for (let o of str) &#123; console.log(o) // l,o,v,e&#125; 循环一个Map123456789101112131415let iterable = new Map([[\"a\", 1], [\"b\", 2], [\"c\", 3]]);for (let [key, value] of iterable) &#123; console.log(value);&#125;// 1// 2// 3for (let entry of iterable) &#123; console.log(entry);&#125;// [a, 1]// [b, 2]// [c, 3] 循环一个Set12345678let iterable = new Set([1, 1, 2, 2, 3, 3]);for (let value of iterable) &#123; console.log(value);&#125;// 1// 2// 3","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"函数参数是按值传递的","slug":"函数参数是按值传递的","date":"2021-04-01T14:43:22.000Z","updated":"2021-04-01T14:53:24.298Z","comments":true,"path":"2021/04/01/函数参数是按值传递的/","link":"","permalink":"http://xerduo.com/2021/04/01/函数参数是按值传递的/","excerpt":"函数参数是按值传递的ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。","text":"函数参数是按值传递的ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用 ECMAScript 的话说，就是 arguments 对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。（这在 ECMAScript 中是不可能的。）来看下面这个例子： 12345678 function addTen(num) &#123; num += 10; return num; &#125; let count = 20;let result = addTen(count); console.log(count); // 20，没有变化console.log(result); // 30 这里，函数 addTen()有一个参数 num，它其实是一个局部变量。在调用时，变量 count 作为参数传入。count 的值是 20，这个值被复制到参数 num 以便在 addTen()内部使用。在函数内部，参数 num的值被加上了 10，但这不会影响函数外部的原始变量 count。参数 num 和变量 count 互不干扰，它们只不过碰巧保存了一样的值。如果 num 是按引用传递的，那么 count 的值也会被修改为 30。这个事实在使用数值这样的原始值时是非常明显的。但是，如果变量中传递的是对象，就没那么清楚了。比如，再看这个例子： 123456function setName(obj) &#123; obj.name = \"Nicholas\"; &#125; let person = new Object(); setName(person); console.log(person.name); // \"Nicholas\" 这一次，我们创建了一个对象并把它保存在变量 person 中。然后，这个对象被传给 setName()方法，并被复制到参数 obj 中。在函数内部，obj 和 person 都指向同一个对象。结果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象。当函数内部给 obj 设置了 name 属性时，函数外部的对象也会反映这个变化，因为 obj 指向的对象保存在全局作用域的堆内存上。很多开发者错误地认为，当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子：12345678function setName(obj) &#123; obj.name = \"Nicholas\"; obj = new Object(); obj.name = \"Greg\"; &#125; let person = new Object(); setName(person); console.log(person.name); // \"Nicholas\" 这个例子前后唯一的变化就是 setName()中多了两行代码，将 obj 重新定义为一个有着不同 name的新对象。当 person 传入 setName()时，其 name 属性被设置为”Nicholas”。然后变量 obj 被设置为一个新对象且 name 属性被设置为”Greg”。如果 person 是按引用传递的，那么 person 应该自动将指针改为指向 name 为”Greg”的对象。可是，当我们再次访问 person.name 时，它的值是”Nicholas”，这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。 注意 ECMAScript 中函数的参数就是局部变量。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"前端页面自动渲染AE动画方案","slug":"前端页面自动渲染AE动画方案","date":"2021-03-10T07:57:22.000Z","updated":"2021-03-10T08:38:19.842Z","comments":true,"path":"2021/03/10/前端页面自动渲染AE动画方案/","link":"","permalink":"http://xerduo.com/2021/03/10/前端页面自动渲染AE动画方案/","excerpt":"前端页面自动渲染AE动画方案在项目中，登录页面设计师做了很酷炫的动画效果，开始我们想到的三种实现方式：1、导出GIF图给前端渲染2、导出视频给前端渲染3、导出动画的每一帧图片给前端序列合成动画后来这三种方式因显示效果不好，体积大或者实现复杂等原因被否定了。","text":"前端页面自动渲染AE动画方案在项目中，登录页面设计师做了很酷炫的动画效果，开始我们想到的三种实现方式：1、导出GIF图给前端渲染2、导出视频给前端渲染3、导出动画的每一帧图片给前端序列合成动画后来这三种方式因显示效果不好，体积大或者实现复杂等原因被否定了。 调研经调研发现 Lottie是可应用于Android, iOS, Web和Windows的库，通过Bodymovin解析AE动画，并导出可在移动端和web端渲染动画的json文件。换言之，设计师用AE把动画效果做出来，再用Bodymovin导出相应地json文件给到前端，前端使用Lottie库就可以实现动画效果，如下图: 设计师安装与使用Bodymovin1、关闭AE2、下载并安装ZXP installer https://aescripts.com/learn/zxp-installer/3、下载最新版bodymovin插件 https://github.com/airbnb/lottie-web/blob/master/build/extension/bodymovin.zxp4、把下载好的bodymovin.zxp拖到ZXP installer5、打开AE，在菜单首选项-&gt;常规中勾选☑️允许脚本写入文件和访问网络（否则输出JSON文件时会失败）6、在AE中制作动画，打开菜单窗口-&gt;拓展-&gt;Bodymovin，勾选要输出的动画，并设置输出文件目录，点击render打开输出目录会看到生成的JSON文件，若动画里导入了外部图片，则会在images中存放JSON中引用的图片 前端安装与使用lottie1、安装依赖 npm install lottie-web2、调用 lottie // 引入lottie import lottie from 'lottie-web'; /* */ // 使用 this.animation = lottie.loadAnimation({ container: this.$refs.loginContent, renderer: 'svg', loop: true, autoplay: true, animationData: loginJson, assetsPath: '/static/animation/login/', }); loadAnimation参数 参数 释义 container 用于渲染动画的HTML元素，需确保在调用loadAnimation时该元素已存在 renderer 渲染器，可选值为’svg’（默认值）/‘canvas’/‘html’。 loop 默认值为true。可传递需要循环的特定次数 autoplay 自动播放 path JSON文件路径 animationData JSON数据，与path互斥 name 传递该参数后，可在之后通过lottie命令引用该动画实例 rendererSettings 可传递给renderer实例的特定设置，具体可看 （renderer html的性能更好且支持3d图层） 调试由于创建Lottie动画和平常制作AE动画有所不同，设计师和前端之间有个动画效果联调的过程，为了提高联调效率，设计师可先进行初步的效果预览，再把文件交付给前端。 预览方法1、渲染前设置所要渲染的文件 2、勾选☑️Demo选项 在输出的文件目录中就可找到可预览的html文件 设计师注意事项 对设计师而言，创建Lottie动画和往常制作AE动画有所不同，此文档 (https://airbnb.io/lottie/#/supported-features) 记录了Bodymovin支持输出的AE功能列表，动画制作前需跟设计师沟通好，根据动画加载平台来确认可使用的AE功能。 除此之外，尽量遵循官方文档里对设计过程的指导和建议：1、动画简单化。 创建动画时需时刻记着保持JSON文件的精简，比如尽可能地绑定父子关系，在相似的图层上复制相同的关键帧会增加额外的代码，尽量不使用占用空间最多的路径关键帧动画。诸如自动跟踪描绘、颤动之类的技术会使得JSON文件变得非常大且耗性能。 2、建立形状图层。将AI、EPS、SVG和PDF等资源转换成形状图层否则无法在Lottie中正常使用，转换好后注意删除该资源以防被导出到JSON文件。 3、设置尺寸。在AE中可设置合成尺寸为任意大小，但需确保导出时合成尺寸和资源尺寸大小保持一致。 4、不使用表达式和特效。Lottie暂不支持。 5、注意遮罩尺寸。若使用alpha遮罩，遮照的大小会对性能产生很大的影响。尽可能地把遮罩尺寸维持到最小。 6、动画调试。若输出动画破损，通过每次导出特定图层来调试出哪些图层出了问题。然后在github中附上该图层文件提交问题，选择用其他方式重构该图层。 7、不使用混合模式和亮度蒙版。 8、不添加图层样式。 9、全屏动画。设置比想要支持的最宽屏幕更宽的导出尺寸。 10、设置空白对象。若使用空白对象，需确保勾选可见并设置透明度为0%否则不会被导出到JSON文件。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"Windows结束某个端口的进程","slug":"Windows结束某个端口的进程","date":"2021-03-08T13:04:12.000Z","updated":"2021-03-08T13:22:56.250Z","comments":true,"path":"2021/03/08/Windows结束某个端口的进程/","link":"","permalink":"http://xerduo.com/2021/03/08/Windows结束某个端口的进程/","excerpt":"Windows结束某个端口的进程以8080端口号为例1.打开cmd命令窗口，输入命令：1netstat -ano | findstr 8080 根据端口号查找对应的PID。发现8080端口被PID（进程号）为2188的进程占用。","text":"Windows结束某个端口的进程以8080端口号为例1.打开cmd命令窗口，输入命令：1netstat -ano | findstr 8080 根据端口号查找对应的PID。发现8080端口被PID（进程号）为2188的进程占用。2.根据PID找进程名称，输入命令：1tasklist | findstr 2181 发现是占用8080端口的进程为：javaw.exe。 3.根据PID结束对应进程。输入命令：1taskkill -PID 2188 -F 强制关闭PID为2188的进程。","categories":[{"name":"Windows","slug":"Windows","permalink":"http://xerduo.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://xerduo.com/tags/Windows/"}]},{"title":"JS类型检测","slug":"js类型检测","date":"2021-03-08T08:51:08.000Z","updated":"2021-03-08T13:17:41.620Z","comments":true,"path":"2021/03/08/js类型检测/","link":"","permalink":"http://xerduo.com/2021/03/08/js类型检测/","excerpt":"JS类型检测在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示： 基本类型：String、Number、Boolean、Symbol、Undefined、Null引用类型：Object 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。 鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，不同的方法得到的结果参差不齐。 下面介绍常用的4种方法，并对各个方法存在的问题进行简单的分析。","text":"JS类型检测在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示： 基本类型：String、Number、Boolean、Symbol、Undefined、Null引用类型：Object 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。 鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，不同的方法得到的结果参差不齐。 下面介绍常用的4种方法，并对各个方法存在的问题进行简单的分析。 typeof 1234567891011console.log(typeof \"\"); // string 有效console.log(typeof 1); // number 有效console.log(typeof Symbol()); // symbol 有效console.log(typeof true); // boolean 有效console.log(typeof undefined); // undefined 有效console.log(typeof null); // object 有效console.log(typeof []); // object 有效console.log(typeof function()&#123;&#125;); // function 有效console.log(typeof &#123;&#125;); // objectconsole.log(typeof new Date()); // objectconsole.log(typeof new RegExp()); // object 有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值： 对于基本类型，除 null 以外，均可以返回正确的结果。 对于引用类型，除 function 以外，一律返回 object 类型。 对于 null ，返回 object 类型。 对于 function 返回 function 类型。其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。 instanceofinstanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，我们用一段伪代码来模拟其内部执行过程： constructorObject.prototype.toString.call()toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。 12345678910111213Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ;// [object Boolean]Object.prototype.toString.call(Symbol());//[object Symbol]Object.prototype.toString.call(undefined) ;// [object Undefined]Object.prototype.toString.call(null) ;// [object Null]Object.prototype.toString.call(newFunction()) ;// [object Function]Object.prototype.toString.call(newDate()) ;// [object Date]Object.prototype.toString.call([]) ;// [object Array]Object.prototype.toString.call(newRegExp()) ;// [object RegExp]Object.prototype.toString.call(newError()) ;// [object Error]Object.prototype.toString.call(document) ;// [object HTMLDocument]Object.prototype.toString.call(window) ;//[object global] window 是全局对象 global 的引用","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"null与undefined","slug":"null与undefined","date":"2021-03-08T02:50:11.000Z","updated":"2021-04-01T15:06:02.818Z","comments":true,"path":"2021/03/08/null与undefined/","link":"","permalink":"http://xerduo.com/2021/03/08/null与undefined/","excerpt":"undefined与null ECMAScript 的原始类型中，是有Undefined 和 Null 类型的。 这两种类型都分别对应了属于自己的唯一专用值，即undefined 和 null。 ECMAScript 有 6 种简单数据类型（也称为原始类型）： Undefined、Null、Boolean、Number、String 和 Symbol 。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。","text":"undefined与null ECMAScript 的原始类型中，是有Undefined 和 Null 类型的。 这两种类型都分别对应了属于自己的唯一专用值，即undefined 和 null。 ECMAScript 有 6 种简单数据类型（也称为原始类型）： Undefined、Null、Boolean、Number、String 和 Symbol 。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义（1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined 主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为 了正式明确空对象指针（null）和未初始化变量的区别。 null Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回”object”的原因：let car = null;console.log(typeof car); // “object”在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用 （1）在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。 // （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。Object.getPrototypeOf(Object.prototype)// null 检测1、可以使用 String()转型函数，它始终会返回表示相应类型值的字符串12String(null) // &apos;null&apos; ,String(undefined) // &apos;undefined&apos; 2、使用 Object.prototype.toString.call(arg)12Object.prototype.toString.call(undefined) ; // &quot;[object Undefined]&quot;Object.prototype.toString.call(null) ; // &quot;[object Null]&quot; 历史原因1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0。 1234Number(null)// 05 + null// 5 但是，JavaScript的设计者Brendan Eich（布兰登·艾克），觉得这样做还不够，有两个原因。 首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象。 其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。 因此，Brendan Eich又设计了一个undefined。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"🎮基于canvas的俄罗斯方块游戏","slug":"基于canvas的俄罗斯方块游戏","date":"2021-01-03T07:00:53.000Z","updated":"2021-03-05T13:58:59.924Z","comments":true,"path":"2021/01/03/基于canvas的俄罗斯方块游戏/","link":"","permalink":"http://xerduo.com/2021/01/03/基于canvas的俄罗斯方块游戏/","excerpt":"演示地址 点击这里 使用方法 12// html部分&lt;div id=\"tetris\"&gt;&lt;/div&gt; 1234// Js部分 var tetris = new Tetris(&#123; id:\"tetris\"&#125;);","text":"演示地址 点击这里 使用方法 12// html部分&lt;div id=\"tetris\"&gt;&lt;/div&gt; 1234// Js部分 var tetris = new Tetris(&#123; id:\"tetris\"&#125;); 界面预览游戏开始 游戏进行中 游戏结束","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://xerduo.com/tags/游戏/"}]}]}