{"meta":{"title":"小耳朵","subtitle":null,"description":null,"author":"Duer","url":"http://xerduo.com"},"pages":[{"title":"","date":"2021-03-05T13:58:59.927Z","updated":"2021-03-05T13:58:59.927Z","comments":true,"path":"google184e1e684149229c.html","permalink":"http://xerduo.com/google184e1e684149229c.html","excerpt":"","text":"google-site-verification: google184e1e684149229c.html"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2021-03-05T13:58:59.925Z","comments":false,"path":"categories/index.html","permalink":"http://xerduo.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-01-19T06:58:08.000Z","updated":"2021-03-08T13:45:12.295Z","comments":true,"path":"about/index.html","permalink":"http://xerduo.com/about/index.html","excerpt":"","text":"关于我1234567&#123; \"name\": \"Duer\", \"Github\": \"https://github.com/adoer\", \"blog\": \"www.xerduo.com\", \"email\": \"duqingbetter@qq.com\", \"WeChat\": \"duerKing\",&#125;"},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2021-03-05T13:58:59.928Z","comments":true,"path":"tags/index.html","permalink":"http://xerduo.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue渲染器的核心Diff算法","slug":"Vue渲染器的核心Diff算法","date":"2021-07-13T14:21:53.000Z","updated":"2021-07-13T14:22:44.351Z","comments":true,"path":"2021/07/13/Vue渲染器的核心Diff算法/","link":"","permalink":"http://xerduo.com/2021/07/13/Vue渲染器的核心Diff算法/","excerpt":"参考文献http://hcysun.me/vue-design/zh/renderer-diff.html#%E5%87%8F%E5%B0%8Fdom%E6%93%8D%E4%BD%9C%E7%9A%84%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80","text":"参考文献http://hcysun.me/vue-design/zh/renderer-diff.html#%E5%87%8F%E5%B0%8Fdom%E6%93%8D%E4%BD%9C%E7%9A%84%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"http://xerduo.com/tags/Vue2/"}]},{"title":"Vue生命周期的理解","slug":"Vue生命周期的理解","date":"2021-07-13T14:18:19.000Z","updated":"2021-07-13T14:18:52.149Z","comments":true,"path":"2021/07/13/Vue生命周期的理解/","link":"","permalink":"http://xerduo.com/2021/07/13/Vue生命周期的理解/","excerpt":"参考文献https://blog.csdn.net/weixin_42707287/article/details/111641286?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162618404616780255234286%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=162618404616780255234286&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-111641286.pc_search_result_before_js&amp;utm_term=vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&amp;spm=1018.2226.3001.4187","text":"参考文献https://blog.csdn.net/weixin_42707287/article/details/111641286?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162618404616780255234286%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=162618404616780255234286&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-111641286.pc_search_result_before_js&amp;utm_term=vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&amp;spm=1018.2226.3001.4187","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"http://xerduo.com/tags/Vue2/"}]},{"title":"Vue中的v-show和v-if怎么理解","slug":"Vue中的v-show和v-if怎么理解","date":"2021-07-13T12:53:06.000Z","updated":"2021-07-13T12:54:04.206Z","comments":true,"path":"2021/07/13/Vue中的v-show和v-if怎么理解/","link":"","permalink":"http://xerduo.com/2021/07/13/Vue中的v-show和v-if怎么理解/","excerpt":"一、v-show与v-if的共同点我们都知道在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示","text":"一、v-show与v-if的共同点我们都知道在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示在用法上也是相同的 12&lt;Model v-show=\"isShow\" /&gt;&lt;Model v-if=\"isShow\" /&gt; 当表达式为true的时候，都会占据页面的位置 当表达式都为false时，都不会占据页面位置 二、v-show与v-if的区别 控制手段不同 编译过程不同 编译条件不同 控制手段：v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换 编译条件：v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染 v-show 由false变为true的时候不会触发组件的生命周期 v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗； 三、v-show与v-if原理分析具体解析流程这里不展开讲，大致流程如下 将模板template转为ast结构的JS对象 用ast得到的JS对象拼装render和staticRenderFns函数 render和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息 vm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点 v-show原理不管初始条件是什么，元素总是会被渲染 我们看一下在vue中是如何实现的 代码很好理解，有transition就执行transition，没有就直接设置display属性 12345678910111213141516171819202122// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.tsexport const vShow: ObjectDirective&lt;VShowElement= &#123; beforeMount(el, &#123; value &#125;, &#123; transition &#125;) &#123; el._vod = el.style.display === 'none' ? '' : el.style.display if (transition &amp;&amp; value) &#123; transition.beforeEnter(el) &#125; else &#123; setDisplay(el, value) &#125; &#125;, mounted(el, &#123; value &#125;, &#123; transition &#125;) &#123; if (transition &amp;&amp; value) &#123; transition.enter(el) &#125; &#125;, updated(el, &#123; value, oldValue &#125;, &#123; transition &#125;) &#123; // ... &#125;, beforeUnmount(el, &#123; value &#125;) &#123; setDisplay(el, value) &#125;&#125; v-if原理v-if在实现上比v-show要复杂的多，因为还有else else-if 等条件需要处理，这里我们也只摘抄源码中处理 v-if 的一小部分 返回一个node节点，render函数通过表达式的值来决定是否生成DOM 1234567891011121314151617181920212223242526// https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.tsexport const transformIf = createStructuralDirectiveTransform( /^(if|else|else-if)$/, (node, dir, context) =&#123; return processIf(node, dir, context, (ifNode, branch, isRoot) =&#123; // ... return () =&#123; if (isRoot) &#123; ifNode.codegenNode = createCodegenNodeForBranch( branch, key, context ) as IfConditionalExpression &#125; else &#123; // attach this branch's codegen node to the v-if root. const parentCondition = getParentCondition(ifNode.codegenNode!) parentCondition.alternate = createCodegenNodeForBranch( branch, key + ifNode.branches.length - 1, context ) &#125; &#125; &#125;) &#125;) 四、v-show与v-if的使用场景v-if 与 v-show 都能控制dom元素在页面的显示 v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除） 如果需要非常频繁地切换，则使用 v-show 较好 如果在运行时条件很少改变，则使用 v-if 较好 参考文献 https://www.jianshu.com/p/7af8554d8f08 https://juejin.cn/post/6897948855904501768 https://vue3js/docs/zh","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"http://xerduo.com/tags/Vue2/"}]},{"title":"Vue双向数据绑定","slug":"Vue双向数据绑定","date":"2021-07-13T12:10:59.000Z","updated":"2021-07-13T12:13:10.222Z","comments":true,"path":"2021/07/13/Vue双向数据绑定/","link":"","permalink":"http://xerduo.com/2021/07/13/Vue双向数据绑定/","excerpt":"参考链接https://www.jianshu.com/p/5fe2664ff5f7","text":"参考链接https://www.jianshu.com/p/5fe2664ff5f7","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"http://xerduo.com/tags/Vue2/"}]},{"title":"对vue的理解","slug":"对vue的理解","date":"2021-07-12T13:08:04.000Z","updated":"2021-07-12T13:14:30.125Z","comments":true,"path":"2021/07/12/对vue的理解/","link":"","permalink":"http://xerduo.com/2021/07/12/对vue的理解/","excerpt":"一、从历史说起Web是World Wide Web的简称，中文译为万维网我们可以将它规划成如下的几个时代来进行理解 石器时代 文明时代 工业革命时代 百花齐放时代","text":"一、从历史说起Web是World Wide Web的简称，中文译为万维网我们可以将它规划成如下的几个时代来进行理解 石器时代 文明时代 工业革命时代 百花齐放时代 石器时代石器时代指的就是我们的静态网页，可以欣赏一下1997的Apple官网 最早的网页是没有数据库的，可以理解成就是一张可以在网络上浏览的报纸，直到CGI技术的出现通过 CGI Perl 运行一小段代码与数据库或文件系统进行交互，如当时的Google（1998年） 文明时代ASP，JSP大家应该都不会太陌生，最早出现于 2005 年左右，先后出现了微软的 ASP 和 Java Server Pages [JSP] 等技术,取代了 CGI ，增强了 WEB 与服务端的交互的安全性，类似于下面这样，其实就是Java + HTML `&lt;%@ page language=”java” contentType=”text/html; charset=utf-8” pageEncoding=”utf-8”%&gt; &lt;title&gt;JSP demo&lt;/title ` JSP有一个很大的缺点，就是不太灵活，因为JSP是在服务器端执行的，通常返回该客户端的就是一个HTML文本。我们每次的请求：获取的数据、内容的加载，都是服务器为我们返回渲染完成之后的 DOM，这也就使得我们开发网站的灵活度大打折扣在这种情况下，同年：Ajax火了(小细节，这里为什么说火了，因为 Ajax 技术并不是 2005 年出现的，他的雏形是 1999 年)，现在看来很常见的技术手段，在当时可是珍贵无比 工业革命时代到这里大家就更熟悉了，移动设备的普及，Jquery的出现，以及SPA（Single Page Application 单页面应用）的雏形，Backbone EmberJS AngularJS 这样一批前端框架随之出现，但当时SPA的路不好走，例如SEO问题，SPA 过多的页面、复杂场景下 View 的绑定等，都没有很好的处理经过这几年的飞速发展，节约了开发人员大量的精力、降低了开发者和开发过程的门槛，极大提升了开发效率和迭代速度，我们可以称之其为工业时代 百花齐放时代这里没有文字，放一张图感受一下 PS：这里为什么要说这么多Web的历史，我们可以看到Web技术的变化之大与快，每一种新的技术出现都是一些特定场景的解决方案，那我们今天的主角Vue又是为了解决什么呢？我们接着往下看 二、vue是什么Vue.js（/vjuː/，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。2016年一项针对JavaScript的调查表明，Vue有着89%的开发者满意度。在GitHub上，该项目平均每天能收获95颗星，为Github有史以来星标数第3多的项目同时也是一款流行的JavaScript前端框架，旨在更好地组织与简化Web开发。Vue所关注的核心是MVC模式中的视图层，同时，它也能方便地获取数据更新，并通过组件内部特定的方法实现视图与模型的交互PS: Vue作者尤雨溪是在为AngularJS工作之后开发出了这一框架。他声称自己的思路是提取Angular中为自己所喜欢的部分，构建出一款相当轻量的框架最早发布于2014年2月 三、Vue核心特性数据驱动（MVVM)MVVM表示的是 Model-View-ViewModel Model：模型层，负责处理业务逻辑以及和服务器端进行交互 View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁 这时候需要一张直观的关系图，如下 组件化1.什么是组件化一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件2.组件化的优势 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级 指令系统解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM 常用的指令 条件渲染指令 v-if 列表渲染指令v-for 属性绑定指令v-bind 事件绑定指令v-on 双向数据绑定指令v-model 没有指令之前我们是怎么做的？是不是先要获取到DOM然后在….干点啥 四、Vue跟传统开发的区别没有落地使用场景的革命不是好革命，就以一个高频的应用场景来示意吧注册账号这个需求大家应该很熟悉了，如下 用jquery来实现大概的思路就是选择流程dom对象，点击按钮隐藏当前活动流程dom对象，显示下一流程dom对象如下图(代码就不上了，上了就篇文章就没了..) 用vue来实现，我们知道vue基本不操作dom节点， 双向绑定使dom节点跟视图绑定后，通过修改变量的值控制dom节点的各类属性。所以其实现思路为：视图层使用一变量控制dom节点显示与否，点击按钮则改变该变量，如下图 总结就是： Vue所有的界面事件，都是只去操作数据的，Jquery操作DOM Vue所有界面的变动，都是根据数据自动绑定出来的，Jquery操作DOM 五、Vue和React对比这里就做几个简单的类比吧，当然没有好坏之分，只是使用场景不同 相同点 都有组件化思想 都支持服务器端渲染 都有Virtual DOM（虚拟dom） 数据驱动视图 都有支持native的方案：Vue的weex、React的React native 都有自己的构建工具：Vue的vue-cli、React的Create React App 区别 数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据 组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数 diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM 参考文献 https://github.com/febobo/web-interview/issues/1 https://segmentfault.com/a/1190000016269636 https://zh.wikipedia.org/zh-cn/Vue.js https://zhuanlan.zhihu.com/p/20197803 https://zhuanlan.zhihu.com/p/38296857","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"http://xerduo.com/tags/Vue2/"}]},{"title":"能实现多少种水平垂直居中的布局？","slug":"能实现多少种水平垂直居中的布局？","date":"2021-07-11T15:55:19.000Z","updated":"2021-07-11T16:16:22.238Z","comments":true,"path":"2021/07/11/能实现多少种水平垂直居中的布局？/","link":"","permalink":"http://xerduo.com/2021/07/11/能实现多少种水平垂直居中的布局？/","excerpt":"参考文献https://juejin.cn/post/6844903982960214029#heading-18","text":"参考文献https://juejin.cn/post/6844903982960214029#heading-18","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://xerduo.com/tags/CSS/"}]},{"title":"对BFC的理解","slug":"对BFC的理解","date":"2021-07-11T13:46:20.000Z","updated":"2021-07-11T13:46:54.251Z","comments":true,"path":"2021/07/11/对BFC的理解/","link":"","permalink":"http://xerduo.com/2021/07/11/对BFC的理解/","excerpt":"一、是什么我们在页面布局的时候，经常出现以下情况： 这个元素高度怎么没了？ 这两栏布局怎么没法自适应？ 这两个元素的间距怎么有点奇怪的样子？ …… 原因是元素之间相互的影响，导致了意料之外的情况，这里就涉及到BFC概念","text":"一、是什么我们在页面布局的时候，经常出现以下情况： 这个元素高度怎么没了？ 这两栏布局怎么没法自适应？ 这两个元素的间距怎么有点奇怪的样子？ …… 原因是元素之间相互的影响，导致了意料之外的情况，这里就涉及到BFC概念BFC（Block Formatting Context），即块级格式化上下文，它是页面中的一块渲染区域，并且有一套属于自己的渲染规则： 内部的盒子会在垂直方向上一个接一个的放置 对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关。 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此 BFC的区域不会与float的元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 BFC目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素 二、触发条件触发BFC的条件包含不限于： 根元素，即HTML元素 浮动元素：float值为left、right overflow值不为 visible，为 auto、scroll、hidden display的值为inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid position的值为absolute或fixed 三、应用场景利用BFC的特性，我们将BFC应用在以下场景： 防止margin重叠（塌陷）1234567891011121314&lt;style&gt; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p &gt; &lt;p&gt;Hehe&lt;/p &gt;&lt;/body&gt; 页面显示如下： 两个p元素之间的距离为100px，发生了margin重叠（塌陷），以最大的为准，如果第一个P的margin为80的话，两个P之间的距离还是100，以最大的为准。 前面讲到，同一个BFC的俩个相邻的盒子的margin会发生重叠 可以在p外面包裹一层容器，并触发这个容器生成一个BFC，那么两个p就不属于同一个BFC，则不会出现margin重叠 12345678910111213141516171819&lt;style&gt; .wrap &#123; overflow: hidden;// 新的BFC &#125; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p &gt; &lt;div class=&quot;wrap&quot;&gt; &lt;p&gt;Hehe&lt;/p &gt; &lt;/div&gt;&lt;/body&gt; 这时候，边距则不会重叠： 清除内部浮动12345678910111213141516171819&lt;style&gt; .par &#123; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width:100px; height: 100px; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;par&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 页面显示如下： 而BFC在计算高度时，浮动元素也会参与，所以我们可以触发.par元素生活才能BFC，则内部浮动元素计算高度时候也会计算 123.par &#123; overflow: hidden;&#125; 实现效果如下： 自适应多栏布局这里举个两栏的布局 12345678910111213141516171819202122&lt;style&gt; body &#123; width: 300px; position: relative; &#125; .aside &#123; width: 100px; height: 150px; float: left; background: #f66; &#125; .main &#123; height: 200px; background: #fcc; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/body&gt; 效果图如下： 前面讲到，每个元素的左外边距与包含块的左边界相接触 因此，虽然.aslide为浮动元素，但是main的左边依然会与包含块的左边相接触 而BFC的区域不会与浮动盒子重叠 所以我们可以通过触发main生成BFC，以此适应两栏布局 123.main &#123; overflow: hidden;&#125; 这时候，新的BFC不会与浮动的.aside元素重叠。因此会根据包含块的宽度，和.aside的宽度，自动变窄 效果如下： 小结可以看到上面几个案例，都体现了BFC实际就是页面一个独立的容器，里面的子元素不影响外面的元素 参考文献 https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context https://github.com/zuopf769/notebook/blob/master/fe/BFC%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/README.md","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://xerduo.com/tags/CSS/"}]},{"title":"CSS哪些方式可以隐藏页面元素？","slug":"CSS哪些方式可以隐藏页面元素？","date":"2021-07-11T09:12:23.000Z","updated":"2021-07-11T09:15:28.269Z","comments":true,"path":"2021/07/11/CSS哪些方式可以隐藏页面元素？/","link":"","permalink":"http://xerduo.com/2021/07/11/CSS哪些方式可以隐藏页面元素？/","excerpt":"一、前言在平常的样式排版中，我们经常遇到将某个模块隐藏的场景 通过css隐藏元素的方法有很多种，它们看起来实现的效果是一致的 但实际上每一种方法都有一丝轻微的不同，这些不同决定了在一些特定场合下使用哪一种方法","text":"一、前言在平常的样式排版中，我们经常遇到将某个模块隐藏的场景 通过css隐藏元素的方法有很多种，它们看起来实现的效果是一致的 但实际上每一种方法都有一丝轻微的不同，这些不同决定了在一些特定场合下使用哪一种方法 二、实现方式通过css实现隐藏元素方法有如下： display:none visibility:hidden opacity:0 设置height、width模型属性为0 position:absolute clip-path display:none设置元素的display为none是最常用的隐藏元素的方法 123.hide &#123; display:none;&#125; 将元素设置为display:none后，元素在页面上将彻底消失 元素本身占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘 消失后，自身绑定的事件不会触发，也不会有过渡效果 特点：元素不可见，不占据空间，无法响应点击事件 visibility:hidden设置元素的visibility为hidden也是一种常用的隐藏元素的方法 从页面上仅仅是隐藏该元素，DOM结果均会存在，只是当时在一个不可见的状态，不会触发重排，但是会触发重绘 123.hidden&#123; visibility:hidden&#125; 给人的效果是隐藏了，所以他自身的事件不会触发 特点：元素不可见，占据页面空间，无法响应点击事件 opacity:0opacity属性表示元素的透明度，将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的 不会引发重排，一般情况下也会引发重绘 如果利用 animation 动画，对 opacity 做变化（animation会默认触发GPU加速），则只会触发 GPU 层面的 composite，不会触发重绘 123.transparent &#123; opacity:0;&#125; 由于其仍然是存在于页面上的，所以他自身的的事件仍然是可以触发的，但被他遮挡的元素是不能触发其事件的 需要注意的是：其子元素不能设置opacity来达到显示的效果 特点：改变元素透明度，元素不可见，占据页面空间，可以响应点击事件 设置height、width属性为0将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其overflow:hidden来隐藏其子元素 12345678.hiddenBox &#123; margin:0; border:0; padding:0; height:0; width:0; overflow:hidden;&#125; 特点：元素不可见，不占据页面空间，无法响应点击事件 position:absolute将元素移出可视区域 12345.hide &#123; position: absolute; top: -9999px; left: -9999px;&#125; 特点：元素不可见，不影响页面布局 clip-path通过裁剪的形式 123.hide &#123; clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);&#125; 特点：元素不可见，占据页面空间，无法响应点击事件 小结最常用的还是display:none和visibility:hidden，其他的方式只能认为是奇招，它们的真正用途并不是用于隐藏元素，所以并不推荐使用它们 三、区别关于display: none、visibility: hidden、opacity: 0的区别，如下表所示： display: none visibility: hidden opacity: 0 页面中 不存在 存在 存在 重排 会 不会 不会 重绘 会 会 不一定 自身绑定事件 不触发 不触发 可触发 transition 不支持 支持 支持 子元素可复原 不能 能 不能 被遮挡的元素可触发事件 能 能 不能 参考文献 https://www.cnblogs.com/a-cat/p/9039962.html","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://xerduo.com/tags/CSS/"}]},{"title":"em/px/rem/vh/vw的区别","slug":"em-px-rem-vh-vw的区别","date":"2021-07-11T08:57:54.000Z","updated":"2021-07-11T08:59:17.898Z","comments":true,"path":"2021/07/11/em-px-rem-vh-vw的区别/","link":"","permalink":"http://xerduo.com/2021/07/11/em-px-rem-vh-vw的区别/","excerpt":"一、介绍传统的项目开发中，我们只会用到px、%、em这几个单位，它可以适用于大部分的项目开发，且拥有比较良好的兼容性","text":"一、介绍传统的项目开发中，我们只会用到px、%、em这几个单位，它可以适用于大部分的项目开发，且拥有比较良好的兼容性从CSS3开始，浏览器对计量单位的支持又提升到了另外一个境界，新增了rem、vh、vw、vm等一些新的计量单位 利用这些新的单位开发出比较良好的响应式页面，适应多种不同分辨率的终端，包括移动设备等 二、单位在css单位中，可以分为长度单位、绝对单位，如下表所指示 CSS单位相对长度单位 em、ex、ch、rem、vw、vh、vmin、vmax、%绝对长度单位 cm、mm、in、px、pt、pc这里我们主要讲述px、em、rem、vh、vw pxpx，表示像素，所谓像素就是呈现在我们显示器上的一个个小点，每个像素点都是大小等同的，所以像素为计量单位被分在了绝对长度单位中 有些人会把px认为是相对长度，原因在于在移动端中存在设备像素比，px实际显示的大小是不确定的 这里之所以认为px为绝对单位，在于px的大小和元素的其他属性无关 emem是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（1em = 16px） 为了简化 font-size 的换算，我们需要在css中的 body 选择器中声明font-size= 62.5%，这就使 em 值变为 16px*62.5% = 10px 这样 12px = 1.2em, 10px = 1em, 也就是说只需要将你的原来的px 数值除以 10，然后换上 em作为单位就行了 特点： em 的值并不是固定的 em 会继承父级元素的字体大小 em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸 任意浏览器的默认字体高都是 16px 举个例子 123&lt;div class=&quot;big&quot;&gt; 我是14px=1.4em&lt;div class=&quot;small&quot;&gt;我是12px=1.2em&lt;/div&gt;&lt;/div&gt; 样式为 12345&lt;style&gt; html &#123;font-size: 10px; &#125; /* 公式16px*62.5%=10px */ .big&#123;font-size: 1.4em&#125; .small&#123;font-size: 1.2em&#125;&lt;/style&gt; 这时候.big元素的font-size为14px，而.small元素的font-size为12px remrem，相对单位，相对的只是HTML根元素font-size的值 同理，如果想要简化font-size的转化，我们可以在根元素html中加入font-size: 62.5% 1html &#123;font-size: 62.5%; &#125; /* 公式16px*62.5%=10px */ 这样页面中1rem=10px、1.2rem=12px、1.4rem=14px、1.6rem=16px;使得视觉、使用、书写都得到了极大的帮助 特点： rem单位可谓集相对大小和绝对大小的优点于一身 和em不同的是rem总是相对于根元素，而不像em一样使用级联的方式来计算尺寸 vh、vwvw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。（vw 始终是针对窗口的宽），同理，vh则为窗口的高度 这里的窗口分成几种情况： 在桌面端，指的是浏览器的可视区域 移动端指的就是布局视口 像vw、vh，比较容易混淆的一个单位是%，不过百分比宽泛的讲是相对于父元素： 对于普通定位元素就是我们理解的父元素 对于position: absolute;的元素是相对于已定位的父元素 对于position: fixed;的元素是相对于 ViewPort（可视窗口） 三、总结px：绝对单位，页面按精确像素展示 em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算，整个页面内1em不是一个固定的值 rem：相对单位，可理解为root em, 相对根节点html的字体大小来计算 vh、vw：主要用于页面视口大小布局，在页面布局上更加方便简单","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://xerduo.com/tags/CSS/"}]},{"title":"对盒子模型的理解?","slug":"对盒子模型的理解","date":"2021-07-11T08:35:35.000Z","updated":"2021-07-11T08:39:38.707Z","comments":true,"path":"2021/07/11/对盒子模型的理解/","link":"","permalink":"http://xerduo.com/2021/07/11/对盒子模型的理解/","excerpt":"一、是什么当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）","text":"一、是什么当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）一个盒子由四个部分组成：content、padding、border、margin content，即实际内容，显示文本和图像 boreder，即边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成 padding，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的background属性影响 margin，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域 下面来段代码： 12345678910&lt;style&gt; .box &#123; width: 200px; height: 100px; padding: 20px; &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt; 盒子模型&lt;/div&gt; 当我们在浏览器查看元素时，却发现元素的大小变成了240px 这是因为，在CSS中，盒子模型可以分成： W3C 标准盒子模型 IE 怪异盒子模型 默认情况下，盒子模型为W3C 标准盒子模型 二、标准盒子模型标准盒子模型，是浏览器默认的盒子模型 盒子总宽度 = width + padding + border + margin; 盒子总高度 = height + padding + border + margin 也就是，width/height 只是内容高度，不包含 padding 和 border值 所以上面问题中，设置width为200px，但由于存在padding，但实际上盒子的宽度有240px 三、IE 怪异盒子模型同样看看IE 怪异盒子模型： 盒子总宽度 = width + margin; 盒子总高度 = height + margin; 也就是，width/height 包含了 padding和 border值 Box-sizingCSS 中的 box-sizing 属性定义了引擎应该如何计算一个元素的总宽度和总高度 语法： 1box-sizing: content-box|border-box|inherit: content-box 默认值，元素的 width/height 不包含padding，border，与标准盒子模型表现一致 border-box 元素的 width/height 包含 padding，border，与怪异盒子模型表现一致 inherit 指定 box-sizing 属性的值，应该从父元素继承 回到上面的例子里，设置盒子为 border-box 模型 1234567891011&lt;style&gt; .box &#123; width: 200px; height: 100px; padding: 20px; box-sizing: border-box; &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt; 盒子模型&lt;/div&gt; 这时候，就可以发现盒子的所占据的宽度为200px 参考文献 https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://xerduo.com/tags/CSS/"}]},{"title":"什么是防抖和节流？有什么区别？如何实现？","slug":"什么是防抖和节流？有什么区别？如何实现？","date":"2021-07-11T06:14:05.000Z","updated":"2021-07-11T08:27:41.674Z","comments":true,"path":"2021/07/11/什么是防抖和节流？有什么区别？如何实现？/","link":"","permalink":"http://xerduo.com/2021/07/11/什么是防抖和节流？有什么区别？如何实现？/","excerpt":"一、是什么本质上是优化高频率执行代码的一种手段 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能","text":"一、是什么本质上是优化高频率执行代码的一种手段 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用debounce（防抖）和 throttle（节流）的方式来减少调用频率 定义 防抖（debounce）: 高频事件触发 n 秒后开始执行函数，若在 n 秒内被重复触发，则重新计时 节流（throttle）: 函数 n 秒内只执行一次，若在 n 秒内重复触发事件，只有一次生效 一个经典的比喻:想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。假设电梯有两种运行策略 debounce 和 throttle ，超时设定为15秒，不考虑容量限制。 debounce 策略的电梯。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。 throttle 策略的电梯。保证如果电梯第一个人进来后，15秒后准时运送一次，不等待。如果没有人，则待机。 代码实现防抖简单版本的实现 123456789101112131415function debounce(func, wait, ...args) &#123; let timeout; return function () &#123; clearTimeout(timeout) timeout = setTimeout(() =&gt; &#123; func.apply(this, args) &#125;, wait); &#125;&#125;// 调用//滚动事件// function f1()&#123;// console.log(1,Array.from(arguments));// &#125;// window.addEventListener('scroll', debounce(f1,500)); 防抖如果需要立即执行，可加入第三个参数用于判断，实现如下： 12345678910111213141516171819202122232425function debounce(func, wait, immediate) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); // timeout 不为null if (immediate) &#123; let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发 timeout = setTimeout(function () &#123; timeout = null; &#125;, wait) if (callNow) &#123; func.apply(context, args) &#125; &#125; else &#123; timeout = setTimeout(function () &#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125; 节流完成节流可以使用时间戳与定时器的写法 使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行 1234567891011function throttled2(fn, delay, ...args) &#123; let timer; return function () &#123; if (!timer) &#123; timer = setTimeout(() =&#123; fn.apply(this, args) timer = null &#125;, delay); &#125; &#125;&#125; 使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行 12345678910function throttled1(fn, delay = 500) &#123; let oldtime = Date.now() return function (...args) &#123; let newtime = Date.now() if (newtime - oldtime &gt;= delay) &#123; fn.apply(null, args) oldtime = Date.now() &#125; &#125;&#125; 可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下 1234567891011121314151617function throttled(fn, delay) &#123; let timer = null let starttime = Date.now() return function () &#123; let curTime = Date.now() // 当前时间 let remaining = delay - (curTime - starttime) // 从上一次到现在，还剩下多少多余时间 let context = this let args = arguments clearTimeout(timer) if (remaining &lt;= 0) &#123; fn.apply(context, args) starttime = Date.now() &#125; else &#123; timer = setTimeout(fn, remaining); &#125; &#125;&#125; 二、区别相同点： 都可以通过使用 setTimeout 实现 目的都是，降低回调执行频率。节省计算资源 不同点： 函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能 函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次 例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次 三、应用场景防抖在连续的事件，只需触发一次回调的场景有： 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 节流在间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚到底部监听 搜索框，搜索联想功能","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS本地存储的方式有哪些？区别及应用场景？","slug":"JS本地存储的方式有哪些？区别及应用场景？","date":"2021-07-10T14:17:46.000Z","updated":"2021-07-10T14:57:57.948Z","comments":true,"path":"2021/07/10/JS本地存储的方式有哪些？区别及应用场景？/","link":"","permalink":"http://xerduo.com/2021/07/10/JS本地存储的方式有哪些？区别及应用场景？/","excerpt":"一、方式javaScript本地缓存的方法我们主要讲述以下四种： cookie sessionStorage localStorage indexedDB","text":"一、方式javaScript本地缓存的方法我们主要讲述以下四种： cookie sessionStorage localStorage indexedDB cookieCookie，类型为「小型文本文件」，指某些 网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 HTTP无状态导致的问题 作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 cookie有效期、安全性、使用范围的可选属性组成 但是cookie在每次请求中都会被发送，如果不使用 HTTPS并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 cookie保持登录态的网站上，如果 cookie被窃取，他人很容易利用你的 cookie来假扮成你登录网站 关于cookie常用的属性如下： Expires 用于设置 Cookie 的过期时间 1Expires=Wed, 21 Oct 2015 07:28:00 GMT Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比Expires高） 1Max-Age=604800 Domain指定了 Cookie 可以送达的主机名 Path指定了一个 URL路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部 1Path=/docs # /docs/Web/ 下的资源会带 Cookie 首部 标记为 Secure的 Cookie只应通过被HTTPS协议加密过的请求发送给服务端 通过上述，我们可以看到cookie又开始的作用并不是为了缓存而设计出来，只是借用了cookie的特性实现缓存 关于cookie的使用如下： 1document.cookie = '名字=值'; 关于cookie的修改，首先要确定domain和path属性都是相同的才可以，其中有一个不同得时候都会创建出一个新的cookie 12Set-Cookie:name=aa; domain=aa.net; path=/ # 服务端设置document.cookie =name=bb; domain=aa.net; path=/ # 客户端设置 最后cookie的删除，最常用的方法就是给cookie设置一个过期的事件，这样cookie过期后会被浏览器删除 localStorageHTML5新方法，IE8及以上浏览器都兼容 特点 生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的 存储的信息在同一域中是共享的 当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。 大小：5M（跟浏览器厂商有关系） localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡 受同源策略的限制 下面再看看关于localStorage的使用 设置 1localStorage.setItem('username','cfangxu'); 获取 1localStorage.getItem('username') 获取键名 1localStorage.key(0) //获取第一个键名 删除 1localStorage.removeItem('username') 一次性清除所有存储 1localStorage.clear() localStorage 也不是完美的，它有两个缺点： 无法像Cookie一样设置过期时间 只能存入字符串，无法直接存对象 12localStorage.setItem('key', &#123;name: 'value'&#125;);console.log(localStorage.getItem('key')); // '[object, Object]' sessionStoragesessionStorage和 localStorage使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，sessionStorage 将会删除数据 indexedDB扩展的前端存储方式indexedDB, indexedDB是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索 虽然 Web Storage对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案 优点： 储存量理论上没有上限 所有操作都是异步的，相比 LocalStorage 同步操作性能更高，尤其是数据量较大时 原生支持储存JS的对象 是个正经的数据库，意味着数据库能干的事它都能干 缺点： 操作非常繁琐 本身有一定门槛 关于indexedDB的使用基本使用步骤如下： 打开数据库并且开始一个事务 创建一个 object store 构建一个请求来执行一些数据库操作，像增加或提取数据等。 通过监听正确类型的 DOM 事件以等待操作完成。 在操作结果上进行一些操作（可以在 request对象中找到） 关于使用indexdb的使用会比较繁琐，大家可以通过使用Godb.js库进行缓存，最大化的降低操作难度 二、区别关于cookie、sessionStorage、localStorage三者的区别主要如下： 存储大小：cookie数据大小不能超过4k，sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 数据与服务器之间的交互方式，cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端； sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存 三、应用场景在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择： 标记用户与跟踪用户行为的情况，推荐使用cookie 适合长期保存在本地的数据（令牌），推荐使用localStorage 敏感账号一次性登录，推荐使用sessionStorage 存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB 相关连接 https://mp.weixin.qq.com/s/mROjtpoXarN--UDfEMqwhQ https://github.com/chenstarx/GoDB.js","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS中内存泄漏的几种情况？","slug":"JS中内存泄漏的几种情况？","date":"2021-07-10T14:14:22.000Z","updated":"2021-07-10T14:51:27.161Z","comments":true,"path":"2021/07/10/JS中内存泄漏的几种情况？/","link":"","permalink":"http://xerduo.com/2021/07/10/JS中内存泄漏的几种情况？/","excerpt":"一、是什么内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存","text":"一、是什么内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费 程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存 对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃 在C语言中，因为是手动管理内存，内存泄露是经常出现的事情。 123456char * buffer;buffer = (char*) malloc(42);// Do something with bufferfree(buffer); 上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。 这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制” 二、垃圾回收机制Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存 原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存 通常情况下有两种实现方式： 标记清除 引用计数 标记清除JavaScript最常用的垃圾收回机制 当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“ 垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉 在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了 随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存 举个例子： 12345678var m = 0,n = 19 // 把 m,n,add() 标记为进入环境。add(m, n) // 把 a, b, c标记为进入环境。console.log(n) // a,b,c标记为离开环境，等待垃圾回收。function add(a, b) &#123; a++ var c = a + b return c&#125; 引用计数语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放 如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏 12const arr = [1, 2, 3, 4];console.log('hello world'); 面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存 如果需要这块内存被垃圾回收机制释放，只需要设置如下： 1arr = null 通过设置arr为null，就解除了对数组[1,2,3,4]的引用，引用次数变为 0，就被垃圾回收了 小结有了垃圾回收机制，不代表不用关注内存泄露。那些很占空间的值，一旦不再用到，需要检查是否还存在对它们的引用。如果是的话，就必须手动解除引用 三、常见内存泄露情况意外的全局变量 123function foo(arg) &#123; bar = \"this is a hidden global variable\";&#125; 另一种意外的全局变量可能由 this 创建： 12345function foo() &#123; this.variable = \"potential accidental global\";&#125;// foo 调用自己，this 指向了全局对象（window）foo(); 上述使用严格模式，可以避免意外的全局变量 定时器也常会造成内存泄露 12345678var someResource = getData();setInterval(function() &#123; var node = document.getElementById('Node'); if(node) &#123; // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); &#125;&#125;, 1000); 如果id为Node的元素从DOM中移除，该定时器仍会存在，同时，因为回调函数中包含对someResource的引用，定时器外面的someResource也不会被释放 包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放 1234567function bindEvent() &#123; var obj = document.createElement('XXX'); var unused = function () &#123; console.log(obj, '闭包内引用obj obj不会被释放'); &#125;; obj = null; // 解决方法&#125; 没有清理对DOM元素的引用同样造成内存泄露 12345const refA = document.getElementById('refA');document.body.removeChild(refA); // dom删除了console.log(refA, 'refA'); // 但是还存在引用能console出整个div 没有被回收refA = null;console.log(refA, 'refA'); // 解除引用 包括使用事件监听addEventListener监听的时候，在不监听的情况下使用removeEventListener取消对事件监听 参考文献 http://www.ruanyifeng.com/blog/2017/04/memory-leak.html https://zh.wikipedia.org/wiki","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"执行上下文和执行栈是什么？","slug":"执行上下文和执行栈是什么？","date":"2021-07-10T00:36:03.000Z","updated":"2021-07-10T02:27:49.463Z","comments":true,"path":"2021/07/10/执行上下文和执行栈是什么？/","link":"","permalink":"http://xerduo.com/2021/07/10/执行上下文和执行栈是什么？/","excerpt":"一、执行上下文简单的来说，执行上下文是一种对Javascript代码执行环境的抽象概念，也就是说只要有Javascript代码运行，那么它就一定是运行在执行上下文中","text":"一、执行上下文简单的来说，执行上下文是一种对Javascript代码执行环境的抽象概念，也就是说只要有Javascript代码运行，那么它就一定是运行在执行上下文中执行上下文的类型分为三种： 全局执行上下文：只有一个，浏览器中的全局对象就是 window对象，this 指向这个全局对象 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文 Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用 下面给出全局上下文和函数上下文的例子： 紫色框住的部分为全局上下文，蓝色和橘色框起来的是不同的函数上下文。只有全局上下文（的变量）能被其他任何上下文访问 可以有任意多个函数上下文，每次调用函数创建一个新的上下文，会创建一个私有作用域，函数内部声明的任何变量都不能在当前函数作用域外部直接访问 二、生命周期执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段 创建阶段创建阶段即当函数被调用，但未执行任何其内部代码之前 创建阶段做了三件事： 确定 this 的值，也被称为 This Binding LexicalEnvironment（词法环境） 组件被创建 VariableEnvironment（变量环境） 组件被创建 伪代码如下： 12345ExecutionContext = &#123; ThisBinding = &lt;this value&gt;, // 确定this LexicalEnvironment = &#123; ... &#125;, // 词法环境 VariableEnvironment = &#123; ... &#125;, // 变量环境&#125; This Binding确定this的值我们前面讲到，this的值是在执行的时候才能确认，定义的时候不能确认 词法环境词法环境有两个组成部分： 全局环境：是一个没有外部环境的词法环境，其外部环境引用为null，有一个全局对象，this 的值指向这个全局对象 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境 伪代码如下： 1234567891011121314151617GlobalExectionContext = &#123; // 全局执行上下文 LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: \"Object\", // 全局环境 // 标识符绑定在这里 outer: &lt;null // 对外部环境的引用 &#125; &#125;FunctionExectionContext = &#123; // 函数执行上下文 LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: \"Declarative\", // 函数环境 // 标识符绑定在这里 // 对外部环境的引用 outer: &lt;Global or outer function environment reference &#125; &#125; 变量环境变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性 在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定 举个例子 12345678910let a = 20; const b = 30; var c;function multiply(e, f) &#123; var g = 20; return e * f * g; &#125;c = multiply(20, 30); 执行上下文如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647GlobalExectionContext = &#123; ThisBinding: &lt;Global Object&gt;, LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; Type: \"Object\", // 标识符绑定在这里 a: &lt; uninitialized &gt;, b: &lt; uninitialized &gt;, multiply: &lt; func &#125; outer: &lt;null &#125;, VariableEnvironment: &#123; // 变量环境 EnvironmentRecord: &#123; Type: \"Object\", // 标识符绑定在这里 c: undefined, &#125; outer: &lt;null &#125; &#125;FunctionExectionContext = &#123; ThisBinding: &lt;Global Object&gt;, LexicalEnvironment: &#123; EnvironmentRecord: &#123; Type: \"Declarative\", // 标识符绑定在这里 Arguments: &#123;0: 20, 1: 30, length: 2&#125;, &#125;, outer: &lt;GlobalLexicalEnvironment &#125;, VariableEnvironment: &#123; EnvironmentRecord: &#123; Type: \"Declarative\", // 标识符绑定在这里 g: undefined &#125;, outer: &lt;GlobalLexicalEnvironment &#125; &#125; 留意上面的代码，let和const定义的变量a和b在创建阶段没有被赋值，但var声明的变量从在创建阶段被赋值为undefined 这是因为，创建阶段，会在代码中扫描变量和函数声明，然后将函数声明存储在环境中 但变量会被初始化为undefined(var声明的情况下)和保持uninitialized(未初始化状态)(使用let和const声明的情况下) 这就是变量提升的实际原因 执行阶段在这阶段，执行变量赋值、代码执行 如果 Javascript 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 undefined 值 回收阶段执行上下文出栈等待虚拟机回收执行上下文 三、执行栈执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文 当Javascript引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中 每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中 引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文 举个例子： 1234567891011let a = 'Hello World!';function first() &#123; console.log('Inside first function'); second(); console.log('Again inside first function');&#125;function second() &#123; console.log('Inside second function');&#125;first();console.log('Inside Global Execution Context'); 转化成图的形式 简单分析一下流程： 创建全局上下文请压入执行栈 first函数被调用，创建函数执行上下文并压入栈 执行first函数过程遇到second函数，再创建一个函数执行上下文并压入栈 second函数执行完毕，对应的函数执行上下文被推出执行栈，执行下一个执行上下文first函数 first函数执行完毕，对应的函数执行上下文也被推出栈中，然后执行全局上下文 所有代码执行完毕，全局上下文也会被推出栈中，程序结束 参考文献 https://zhuanlan.zhihu.com/p/107552264","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS事件循环的理解","slug":"JS事件循环的理解","date":"2021-07-09T16:12:02.000Z","updated":"2021-07-10T14:52:06.479Z","comments":true,"path":"2021/07/10/JS事件循环的理解/","link":"","permalink":"http://xerduo.com/2021/07/10/JS事件循环的理解/","excerpt":"一、是什么JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事 为什么要这么设计，跟JavaScript的应用场景有关 JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除 DOM ，另一个添加 DOM，此时浏览器该如何处理？ 为了解决单线程运行阻塞问题，JavaScript用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）","text":"一、是什么JavaScript 在设计之初便是单线程，即指程序运行时，只有一个线程存在，同一时间只能做一件事 为什么要这么设计，跟JavaScript的应用场景有关 JavaScript 初期作为一门浏览器脚本语言，通常用于操作 DOM ，如果是多线程，一个线程进行了删除 DOM ，另一个添加 DOM，此时浏览器该如何处理？ 为了解决单线程运行阻塞问题，JavaScript用到了计算机系统的一种运行机制，这种机制就叫做事件循环（Event Loop）事件循环（Event Loop）在JavaScript中，所有的任务都可以分为 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行 异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等 同步任务与异步任务的运行流程图如下： 从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环 二、宏任务与微任务如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子： 1234567891011121314console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123; console.log('new Promise') resolve()&#125;).then(()=&gt;&#123; console.log('then')&#125;)console.log(3) 如果按照上面流程图来分析代码，我们会得到下面的执行步骤： console.log(1)，同步任务，主线程中执行 setTimeout() ，异步任务，放到 Event Table，0 毫秒后console.log(2)回调推入 Event Queue 中 new Promise ，同步任务，主线程直接执行 .then ，异步任务，放到 Event Table console.log(3)，同步任务，主线程执行 所以按照分析，它的结果应该是 1 =&#39;new Promise&#39; =3 =2 =&#39;then&#39; 但是实际结果是：1=&gt;&#39;new Promise&#39;=3 =&#39;then&#39; =2 出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取 例子中 setTimeout回调事件是先进入队列中的，按理说应该先于 .then 中的执行，但是结果却偏偏相反 原因在于异步任务还可以细分为微任务与宏任务 微任务一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前 常见的微任务有： Promise.then MutaionObserver Object.observe（已废弃；Proxy 对象替代） process.nextTick（Node.js） 宏任务宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合 常见的宏任务有： script (可以理解为外层同步代码) setTimeout/setInterval UI rendering/UI事件 postMessage、MessageChannel setImmediate、I/O（Node.js） 这时候，事件循环，宏任务，微任务的关系如图所示 按照这个流程，它的执行机制是： 执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中 当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完 回到上面的题目 1234567891011console.log(1)setTimeout(()=&gt;&#123; console.log(2)&#125;, 0)new Promise((resolve, reject)=&gt;&#123; console.log('new Promise') resolve()&#125;).then(()=&gt;&#123; console.log('then')&#125;)console.log(3) 流程如下 1234567// 遇到 console.log(1) ，直接打印 1// 遇到定时器，属于新的宏任务，留着后面执行// 遇到 new Promise，这个是直接执行的，打印 'new Promise'// .then 属于微任务，放入微任务队列，后面再执行// 遇到 console.log(3) 直接打印 3// 好了本轮宏任务执行完毕，现在去微任务列表查看是否有微任务，发现 .then 的回调，执行它，打印 'then'// 当一次宏任务执行完，再去执行新的宏任务，这里就剩一个定时器的宏任务了，执行它，打印 2 三、async与awaitasync 是异步的意思，await则可以理解为等待 放到一起可以理解async就是用来声明一个异步方法，而 await是用来等待异步方法执行 asyncasync函数返回一个promise对象，下面两种方法是等效的 12345678function f() &#123; return Promise.resolve('TEST');&#125;// asyncF is equivalent to f!async function asyncF() &#123; return 'TEST';&#125; await正常情况下，await命令后面是一个 Promise对象，返回该对象的结果。如果不是 Promise对象，就直接返回对应的值 123456async function f()&#123; // 等同于 // return 123 return await 123&#125;f().then(v =console.log(v)) // 123 不管await后面跟着的是什么，await都会阻塞后面的代码 123456789101112async function fn1 ()&#123; console.log(1) await fn2() console.log(2) // 阻塞&#125;async function fn2 ()&#123; console.log('fn2')&#125;fn1()console.log(3) 上面的例子中，await 会阻塞下面的代码（即加入微任务队列），先执行 async外面的同步代码，同步代码执行完，再回到 async 函数中，再执行之前阻塞的代码 所以上述输出结果为：1，fn2，3，2 四、流程分析通过对上面的了解，我们对JavaScript对各种场景的执行顺序有了大致的了解 这里直接上代码： 1234567891011121314151617181920async function async1() &#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2() &#123; console.log('async2')&#125;console.log('script start')setTimeout(function () &#123; console.log('settimeout')&#125;)async1()new Promise(function (resolve) &#123; console.log('promise1') resolve()&#125;).then(function () &#123; console.log('promise2')&#125;)console.log('script end') 分析过程： 执行整段代码，遇到 console.log(&#39;script start&#39;) 直接打印结果，输出 script start 遇到定时器了，它是宏任务，先放着不执行 遇到 async1()，执行 async1 函数，先打印 async1 start，下面遇到await怎么办？先执行 async2，打印 async2，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码 跳到 new Promise 这里，直接执行，打印 promise1，下面遇到 .then()，它是微任务，放到微任务列表等待执行 最后一行直接打印 script end，现在同步代码执行完了，开始执行微任务，即 await下面的代码，打印 async1 end 继续执行下一个微任务，即执行 then 的回调，打印 promise2 上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 settimeout 所以最后的结果是：script start、async1 start、async2、promise1、script end、async1 end、promise2、settimeout","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"对正则表达式的理解？应用场景？","slug":"对正则表达式的理解？应用场景？","date":"2021-07-09T16:07:40.000Z","updated":"2021-07-09T16:09:18.740Z","comments":true,"path":"2021/07/10/对正则表达式的理解？应用场景？/","link":"","permalink":"http://xerduo.com/2021/07/10/对正则表达式的理解？应用场景？/","excerpt":"一、是什么正则表达式是一种用来匹配字符串的强有力的武器","text":"一、是什么正则表达式是一种用来匹配字符串的强有力的武器它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的 在 JavaScript中，正则表达式也是对象，构建正则表达式有两种方式： 字面量创建，其由包含在斜杠之间的模式组成 1const re = /\\d+/g; 调用RegExp对象的构造函数 1234const re = new RegExp(\"\\\\d+\",\"g\");const rul = \"\\\\d+\"const re1 = new RegExp(rul,\"g\"); 使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符\\需要使用\\\\进行转义 二、匹配规则常见的校验规则如下： 规则 描述\\ 转义^ 匹配输入的开始$ 匹配输入的结束 匹配前一个表达式 0 次或多次 匹配前面一个表达式 1 次或者多次。等价于 {1,}? 匹配前面一个表达式 0 次或者 1 次。等价于{0,1}. 默认匹配除换行符之外的任何单个字符x(?=y) 匹配’x’仅仅当’x’后面跟着’y’。这种叫做先行断言(?&lt;=y)x 匹配’x’仅当’x’前面是’y’.这种叫做后行断言x(?!y) 仅仅当’x’后面不跟着’y’时匹配’x’，这被称为正向否定查找(?&lt;!_y_)_x_ 仅仅当’x’前面不是’y’时匹配’x’，这被称为反向否定查找x|y 匹配‘x’或者‘y’{n} n 是一个正整数，匹配了前面一个字符刚好出现了 n 次{n,} n是一个正整数，匹配前一个字符至少出现了n次{n,m} n 和 m 都是整数。匹配前面的字符至少n次，最多m次[xyz] 一个字符集合。匹配方括号中的任意字符[^xyz] 匹配任何没有包含在方括号中的字符\\b 匹配一个词的边界，例如在字母和空格之间\\B 匹配一个非单词边界\\d 匹配一个数字\\D 匹配一个非数字字符\\f 匹配一个换页符\\n 匹配一个换行符\\r 匹配一个回车符\\s 匹配一个空白字符，包括空格、制表符、换页符和换行符\\S 匹配一个非空白字符\\w 匹配一个单字字符（字母、数字或者下划线）\\W 匹配一个非单字字符正则表达式标记标志 描述g 全局搜索。i 不区分大小写搜索。m 多行搜索。s 允许 . 匹配换行符。u 使用unicode码的模式进行匹配。y 执行“粘性(sticky)”搜索,匹配从目标字符串的当前位置开始。使用方法如下： 12var re = /pattern/flags;var re = new RegExp(\"pattern\", \"flags\"); 在了解下正则表达式基本的之外，还可以掌握几个正则表达式的特性： 贪婪模式在了解贪婪模式前，首先举个例子： 1const reg = /ab&#123;1,3&#125;c/ 在匹配过程中，尝试可能的顺序是从多往少的方向去尝试。首先会尝试bbb，然后再看整个正则是否能匹配。不能匹配时，吐出一个b，即在bb的基础上，再继续尝试，以此重复 如果多个贪婪量词挨着，则深度优先搜索 1234const string = \"12345\";const regx = /(\\d&#123;1,3&#125;)(\\d&#123;1,3&#125;)/;console.log( string.match(reg) );// =[\"12345\", \"123\", \"45\", index: 0, input: \"12345\"] 其中，前面的\\d{1,3}匹配的是”123”，后面的\\d{1,3}匹配的是”45” 懒惰模式惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配 1234var string = \"12345\";var regex = /(\\d&#123;1,3&#125;?)(\\d&#123;1,3&#125;)/;console.log( string.match(regex) );// =[\"1234\", \"1\", \"234\", index: 0, input: \"12345\"] 其中\\d{1,3}?只匹配到一个字符”1”，而后面的\\d{1,3}匹配了”234” 分组分组主要是用过()进行实现，比如beyond{3}，是匹配d字母3次。而(beyond){3}是匹配beyond三次 在()内使用|达到或的效果，如(abc | xxx)可以匹配abc或者xxx 反向引用，巧用$分组捕获 1234let str = \"John Smith\";// 交换名字和姓氏console.log(str.replace(/(john) (smith)/i, '$2, $1')) // Smith, John 三、匹配方法正则表达式常被用于某些方法，我们可以分成两类： 字符串（str）方法：match、matchAll、search、replace、split 正则对象下（regexp）的方法：test、exec 方法 描述exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。test 一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。match 一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。matchAll 一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。 str.match(regexp)str.match(regexp) 方法在字符串 str 中找到匹配 regexp 的字符 如果 regexp 不带有 g 标记，则它以数组的形式返回第一个匹配项，其中包含分组和属性 index（匹配项的位置）、input（输入字符串，等于 str） 1234567891011let str = \"I love JavaScript\";let result = str.match(/Java(Script)/);console.log( result[0] ); // JavaScript（完全匹配）console.log( result[1] ); // Script（第一个分组）console.log( result.length ); // 2// 其他信息：console.log( result.index ); // 7（匹配位置）console.log( result.input ); // I love JavaScript（源字符串） 如果 regexp 带有 g 标记，则它将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息 123456let str = \"I love JavaScript\";let result = str.match(/Java(Script)/g);console.log( result[0] ); // JavaScriptconsole.log( result.length ); // 1 如果没有匹配项，则无论是否带有标记 g ，都将返回 null 12345let str = \"I love JavaScript\";let result = str.match(/HTML/);console.log(result); // null str.matchAll(regexp)返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器 12345678910const regexp = /t(e)(st(\\d?))/g;const str = 'test1test2';const array = [...str.matchAll(regexp)];console.log(array[0]);// expected output: Array [\"test1\", \"e\", \"st1\", \"1\"]console.log(array[1]);// expected output: Array [\"test2\", \"e\", \"st2\", \"2\"] str.search(regexp)返回第一个匹配项的位置，如果未找到，则返回 -1 123let str = \"A drop of ink may make a million think\";console.log( str.search( /ink/i ) ); // 10（第一个匹配位置） 这里需要注意的是，search 仅查找第一个匹配项 str.replace(regexp)替换与正则表达式匹配的子串，并返回替换后的字符串。在不设置全局匹配g的时候，只替换第一个匹配成功的字符串片段 123456const reg1=/javascript/i;const reg2=/javascript/ig;console.log('hello Javascript Javascript Javascript'.replace(reg1,'js'));//hello js Javascript Javascriptconsole.log('hello Javascript Javascript Javascript'.replace(reg2,'js'));//hello js js js str.split(regexp)使用正则表达式（或子字符串）作为分隔符来分割字符串 1console.log('12, 34, 56'.split(/,\\s*/)) // 数组 ['12', '34', '56'] regexp.exec(str)regexp.exec(str) 方法返回字符串 str 中的 regexp 匹配项，与以前的方法不同，它是在正则表达式而不是字符串上调用的 根据正则表达式是否带有标志 g，它的行为有所不同 如果没有 g，那么 regexp.exec(str) 返回的第一个匹配与 str.match(regexp) 完全相同 如果有标记 g，调用 regexp.exec(str) 会返回第一个匹配项，并将紧随其后的位置保存在属性regexp.lastIndex 中。 下一次同样的调用会从位置 regexp.lastIndex 开始搜索，返回下一个匹配项，并将其后的位置保存在 regexp.lastIndex 中 12345678910let str = 'More about JavaScript at https://javascript.info';let regexp = /javascript/ig;let result;while (result = regexp.exec(str)) &#123; console.log( `Found $&#123;result[0]&#125; at position $&#123;result.index&#125;` ); // Found JavaScript at position 11 // Found javascript at position 33&#125; regexp.test(str)查找匹配项，然后返回 true/false 表示是否存在 1234let str = \"I love JavaScript\";// 这两个测试相同console.log( /love/i.test(str) ); // true 四、应用场景通过上面的学习，我们对正则表达式有了一定的了解 下面再来看看正则表达式一些案例场景： 验证QQ合法性（5~15位、全是数字、不以0开头）： 12const reg = /^[1-9][0-9]&#123;4,14&#125;$/const isvalid = patrn.exec(s) 校验用户账号合法性（只能输入5-20个以字母开头、可带数字、“_”、“.”的字串）： 12var patrn=/^[a-zA-Z]&#123;1&#125;([a-zA-Z0-9]|[._])&#123;4,19&#125;$/;const isvalid = patrn.exec(s) 将url参数解析为对象 1234567891011121314151617181920212223242526const protocol = '(?&lt;protocol&gt;https?:)';const host = '(?&lt;host&gt;(?&lt;hostname&gt;[^/#?:]+)(?::(?&lt;port&gt;\\\\d+))?)';const path = '(?&lt;pathname&gt;(?:\\\\/[^/#?]+)*\\\\/?)';const search = '(?&lt;search&gt;(?:\\\\?[^#]*)?)';const hash = '(?&lt;hash&gt;(?:#.*)?)';const reg = new RegExp(`^$&#123;protocol&#125;\\/\\/$&#123;host&#125;$&#123;path&#125;$&#123;search&#125;$&#123;hash&#125;$`);function execURL(url)&#123; const result = reg.exec(url); if(result)&#123; result.groups.port = result.groups.port || ''; return result.groups; &#125; return &#123; protocol:'',host:'',hostname:'',port:'', pathname:'',search:'',hash:'', &#125;;&#125;console.log(execURL('https://localhost:8080/?a=b#xxxx'));protocol: \"https:\"host: \"localhost:8080\"hostname: \"localhost\"port: \"8080\"pathname: \"/\"search: \"?a=b\"hash: \"#xxxx\" 再将上面的search和hash进行解析 123456789101112131415161718function execUrlParams(str)&#123; str = str.replace(/^[#?&amp;]/,''); const result = &#123;&#125;; if(!str)&#123; //如果正则可能配到空字符串，极有可能造成死循环，判断很重要 return result; &#125; const reg = /(?:^|&amp;)([^&amp;=]*)=?([^&amp;]*?)(?=&amp;|$)/y let exec = reg.exec(str); while(exec)&#123; result[exec[1]] = exec[2]; exec = reg.exec(str); &#125; return result;&#125;console.log(execUrlParams('#'));// &#123;&#125;console.log(execUrlParams('##'));//&#123;'#':''&#125;console.log(execUrlParams('?q=3606&amp;src=srp')); //&#123;q: \"3606\", src: \"srp\"&#125;console.log(execUrlParams('test=a=b=c&amp;&amp;==&amp;a='));//&#123;test: \"a=b=c\", \"\": \"=\", a: \"\"&#125; 参考文献 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"什么是事件代理？应用场景？","slug":"什么是事件代理？应用场景？","date":"2021-07-09T15:45:05.000Z","updated":"2021-07-09T15:55:32.189Z","comments":true,"path":"2021/07/09/什么是事件代理？应用场景？/","link":"","permalink":"http://xerduo.com/2021/07/09/什么是事件代理？应用场景？/","excerpt":"一、是什么事件代理，俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素 前面讲到，事件流的都会经过三个阶段： 捕获阶段 -目标阶段 -冒泡阶段，而事件委托就是在冒泡阶段完成 事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素 当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数 下面举个例子：","text":"一、是什么事件代理，俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素 前面讲到，事件流的都会经过三个阶段： 捕获阶段 -目标阶段 -冒泡阶段，而事件委托就是在冒泡阶段完成 事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素 当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数 下面举个例子：比如一个宿舍的同学同时快递到了，一种笨方法就是他们一个个去领取 较优方法就是把这件事情委托给宿舍长，让一个人出去拿好所有快递，然后再根据收件人一一分发给每个同学 在这里，取快递就是一个事件，每个同学指的是需要响应事件的 DOM元素，而出去统一领取快递的宿舍长就是代理的元素 所以真正绑定事件的是这个元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的事件应该匹配到被代理元素中的哪一个或者哪几个 二、应用场景如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件 1234567&lt;ul id=\"list\"&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt; ...... &lt;li&gt;item n&lt;/li&gt;&lt;/ul&gt; 如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的 12345678// 获取目标元素const lis = document.getElementsByTagName(\"li\")// 循环遍历绑定事件for (let i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function(e)&#123; console.log(e.target.innerHTML) &#125;&#125; 这时候就可以事件委托，把点击事件绑定在父级元素ul上面，然后执行事件的时候再去匹配目标元素 12345678910// 给父层元素绑定事件document.getElementById('list').addEventListener('click', function (e) &#123; // 兼容性处理 var event = e || window.event; var target = event.target || event.srcElement; // 判断是否匹配目标元素 if (target.nodeName.toLocaleLowerCase === 'li') &#123; console.log('the content is: ', target.innerHTML); &#125;&#125;); 还有一种场景是上述列表项并不多，我们给每个列表项都绑定了事件 但是如果用户能够随时动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件 如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的 举个例子： 下面html结构中，点击input可以动态添加元素 1234567&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;btn&quot; value=&quot;添加&quot; /&gt;&lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;li&gt;item 3&lt;/li&gt; &lt;li&gt;item 4&lt;/li&gt;&lt;/ul&gt; 使用事件委托 123456789101112131415161718192021const oBtn = document.getElementById(\"btn\");const oUl = document.getElementById(\"ul1\");const num = 4;//事件委托，添加的子元素也有事件oUl.onclick = function (ev) &#123; ev = ev || window.event; const target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == 'li') &#123; console.log('the content is: ', target.innerHTML); &#125;&#125;;//添加新节点oBtn.onclick = function () &#123; num++; const oLi = document.createElement('li'); oLi.innerHTML = `item $&#123;num&#125;`; oUl.appendChild(oLi);&#125;; 可以看到，使用事件委托，在动态绑定事件的情况下是可以减少很多重复工作的 三、总结适合事件委托的事件有：click，mousedown，mouseup，keydown，keyup，keypress 从上面应用场景中，我们就可以看到使用事件委托存在两大优点： 减少整个页面所需的内存，提升整体性能 动态绑定，减少重复工作 但是使用事件委托也是存在局限性： focus、blur这些事件没有事件冒泡机制，所以无法进行委托绑定事件 mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的 如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"谈谈this对象的理解","slug":"谈谈this对象的理解","date":"2021-06-30T16:53:58.000Z","updated":"2021-06-30T16:54:56.891Z","comments":true,"path":"2021/07/01/谈谈this对象的理解/","link":"","permalink":"http://xerduo.com/2021/07/01/谈谈this对象的理解/","excerpt":"一、定义函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别 在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定） this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象","text":"一、定义函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别 在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定） this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象举个例子： 123456789101112131415161718192021222324function baz() &#123; // 当前调用栈是：baz // 因此，当前调用位置是全局作用域 console.log( \"baz\" ); bar(); // &lt;-- bar的调用位置&#125;function bar() &#123; // 当前调用栈是：baz --bar // 因此，当前调用位置在baz中 console.log( \"bar\" ); foo(); // &lt;-- foo的调用位置&#125;function foo() &#123; // 当前调用栈是：baz --bar --foo // 因此，当前调用位置在bar中 console.log( \"foo\" );&#125;baz(); // &lt;-- baz的调用位置 同时，this在函数执行过程中，this一旦被确定了，就不可以再更改 1234567891011var a = 10;var obj = &#123; a: 20&#125;function fn() &#123; this = obj; // 修改this，运行后会报错 console.log(this.a);&#125;fn(); 二、绑定规则根据不同的使用场合，this有不同的值，主要分为下面几种情况： 默认绑定 隐式绑定 new绑定 显示绑定 默认绑定全局环境中定义person函数，内部使用this关键字 12345var name = 'Jenny';function person() &#123; return this.name;&#125;console.log(person()); //Jenny 上述代码输出Jenny，原因是调用函数的对象在游览器中位window，因此this指向window，所以输出Jenny 注意： 严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象 隐式绑定函数还可以作为某个对象的方法调用，这时this就指这个上级对象 123456789function test() &#123; console.log(this.x);&#125;var obj = &#123;&#125;;obj.x = 1;obj.m = test;obj.m(); // 1 这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象 123456789var o = &#123; a:10, b:&#123; fn:function()&#123; console.log(this.a); //undefined &#125; &#125;&#125;o.b.fn(); 上述代码中，this的上一级对象为b，b内部并没有a变量的定义，所以输出undefined 这里再举一种特殊情况 123456789101112var o = &#123; a:10, b:&#123; a:12, fn:function()&#123; console.log(this.a); //undefined console.log(this); //window &#125; &#125;&#125;var j = o.b.fn;j(); 此时this指向的是window，这里的大家需要记住，this永远指向的是最后调用它的对象，虽然fn是对象b的方法，但是fn赋值给j时候并没有执行，所以最终指向window new绑定通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象 123456function test() &#123; this.x = 1;&#125;var obj = new test();obj.x // 1 上述代码之所以能过输出1，是因为new关键字改变了this的指向 这里再列举一些特殊情况： new过程遇到return一个对象，此时this指向为返回的对象 1234567function fn() &#123; this.user = 'xxx'; return &#123;&#125;; &#125;var a = new fn(); console.log(a.user); //undefined 如果返回一个简单类型的时候，则this指向实例对象 1234567function fn() &#123; this.user = 'xxx'; return 1;&#125;var a = new fn; console.log(a.user); //xxx 注意的是null虽然也是对象，但是此时new仍然指向实例对象 1234567function fn() &#123; this.user = 'xxx'; return null;&#125;var a = new fn; console.log(a.user); //xxx 显示修改apply()、call()、bind()是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时this指的就是这第一个参数 123456789var x = 0;function test() &#123; console.log(this.x);&#125;var obj = &#123;&#125;;obj.x = 1;obj.m = test;obj.m.apply(obj) // 1 关于apply、call、bind三者的区别，我们后面再详细说 三、箭头函数在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 this 的指向（编译时绑定） 举个例子： 123456789const obj = &#123; sayThis: () =&#123; console.log(this); &#125;&#125;;obj.sayThis(); // window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了const globalSay = obj.sayThis;globalSay(); // window 浏览器中的 global 对象 虽然箭头函数的this能够在编译的时候就确定了this的指向，但也需要注意一些潜在的坑 下面举个例子： 绑定事件监听 12345const button = document.getElementById('mngb');button.addEventListener('click', ()=&#123; console.log(this === window) // true this.innerHTML = 'clicked button'&#125;) 上述可以看到，我们其实是想要this为点击的button，但此时this指向了window 包括在原型上添加方法时候，此时this指向window 123456Cat.prototype.sayName = () =&#123; console.log(this === window) //true return this.name&#125;const cat = new Cat('mm');cat.sayName() 同样的，箭头函数不能作为构建函数 四、优先级隐式绑定 VS 显式绑定12345678910111213141516171819function foo() &#123; console.log( this.a );&#125;var obj1 = &#123; a: 2, foo: foo&#125;;var obj2 = &#123; a: 3, foo: foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call( obj2 ); // 3obj2.foo.call( obj1 ); // 2 显然，显示绑定的优先级更高 new绑定 VS 隐式绑定12345678910111213141516171819function foo(something) &#123; this.a = something;&#125;var obj1 = &#123; foo: foo&#125;;var obj2 = &#123;&#125;;obj1.foo( 2 );console.log( obj1.a ); // 2obj1.foo.call( obj2, 3 );console.log( obj2.a ); // 3var bar = new obj1.foo( 4 );console.log( obj1.a ); // 2console.log( bar.a ); // 4 可以看到，new绑定的优先级&gt;隐式绑定 new绑定 VS 显式绑定因为new和apply、call无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试 12345678910111213function foo(something) &#123; this.a = something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind( obj1 );bar( 2 );console.log( obj1.a ); // 2var baz = new bar( 3 );console.log( obj1.a ); // 2console.log( baz.a ); // 3 bar被绑定到obj1上，但是new bar(3) 并没有像我们预计的那样把obj1.a修改为3。但是，new修改了绑定调用bar()中的this 我们可认为new绑定优先级&gt;显式绑定 综上，new绑定优先级 显示绑定优先级 隐式绑定优先级 默认绑定优先级 相关链接 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS作用域链的理解","slug":"JS作用域链的理解","date":"2021-06-30T16:51:32.000Z","updated":"2021-07-10T14:52:42.181Z","comments":true,"path":"2021/07/01/JS作用域链的理解/","link":"","permalink":"http://xerduo.com/2021/07/01/JS作用域链的理解/","excerpt":"一、作用域作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合 换句话说，作用域决定了代码区块中变量和其他资源的可见性","text":"一、作用域作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合 换句话说，作用域决定了代码区块中变量和其他资源的可见性举个例子 12345function myFunction() &#123; let inVariable = \"函数内部变量\";&#125;myFunction();//要先执行这个函数，否则根本不知道里面是啥console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined 上述例子中，函数myFunction内部创建一个inVariable变量，当我们在全局访问这个变量的时候，系统会报错 这就说明我们在全局是无法获取到（闭包除外）函数内部的变量 我们一般将作用域分成： 全局作用域 函数作用域 块级作用域 全局作用域任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问 1234567// 全局变量var greeting = 'Hello World!';function greet() &#123; console.log(greeting);&#125;// 打印 'Hello World!'greet(); 函数作用域函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问 12345678function greet() &#123; var greeting = 'Hello World!'; console.log(greeting);&#125;// 打印 'Hello World!'greet();// 报错： Uncaught ReferenceError: greeting is not definedconsole.log(greeting); 可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域 块级作用域ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量 12345678910&#123; // 块级作用域中的变量 let greeting = 'Hello World!'; var lang = 'English'; console.log(greeting); // Prints 'Hello World!'&#125;// 变量 'English'console.log(lang);// 报错：Uncaught ReferenceError: greeting is not definedconsole.log(greeting); 二、词法作用域词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，JavaScript 遵循的就是词法作用域 123456789var a = 2;function foo()&#123; console.log(a)&#125;function bar()&#123; var a = 3; foo();&#125;bar() 上述代码改变成一张图 由于JavaScript遵循词法作用域，相同层级的 foo 和 bar 就没有办法访问到彼此块作用域中的变量，所以输出2 三、作用域链当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域 如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错 这里拿《你不知道的Javascript(上)》中的一张图解释： 把作用域比喻成一个建筑，这份建筑代表程序中的嵌套作用域链，第一层代表当前的执行作用域，顶层代表全局作用域 变量的引用会顺着当前楼层进行查找，如果找不到，则会往上一层找，一旦到达顶层，查找的过程都会停止 下面代码演示下： 123456789101112var sex = '男';function person() &#123; var name = '张三'; function student() &#123; var age = 18; console.log(name); // 张三 console.log(sex); // 男 &#125; student(); console.log(age); // Uncaught ReferenceError: age is not defined&#125;person(); 上述代码主要主要做了以下工作： student函数内部属于最内层作用域，找不到name，向上一层作用域person函数内部找，找到了输出“张三” student内部输出cat时找不到，向上一层作用域person函数找，还找不到继续向上一层找，即全局作用域，找到了输出“男” 在person函数内部输出age时找不到，向上一层作用域找，即全局作用域，还是找不到则报错","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"对闭包的理解？闭包使用场景","slug":"对闭包的理解？闭包使用场景","date":"2021-06-30T16:15:35.000Z","updated":"2021-07-11T03:24:28.572Z","comments":true,"path":"2021/07/01/对闭包的理解？闭包使用场景/","link":"","permalink":"http://xerduo.com/2021/07/01/对闭包的理解？闭包使用场景/","excerpt":"一、是什么一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）","text":"一、是什么一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域 在 JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁 下面给出一个简单的例子 12345678function init() &#123; var name = \"Mozilla\"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数，一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; displayName();&#125;init(); displayName() 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量 二、使用场景任何闭包的使用场景都离不开这两点： 创建私有变量 延长变量的生命周期 一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的 下面举个例子： 在页面上添加一些可以调整字号的按钮 12345678910111213function makeSizer(size) &#123; return function() &#123; document.body.style.fontSize = size + 'px'; &#125;;&#125;var size12 = makeSizer(12);var size14 = makeSizer(14);var size16 = makeSizer(16);document.getElementById('size-12').onclick = size12;document.getElementById('size-14').onclick = size14;document.getElementById('size-16').onclick = size16; 柯里化函数柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用 12345678910111213141516171819202122// 假设我们有一个求长方形面积的函数function getArea(width, height) &#123; return width * height&#125;// 如果我们碰到的长方形的宽老是10const area1 = getArea(10, 20)const area2 = getArea(10, 30)const area3 = getArea(10, 40)// 我们可以使用闭包柯里化这个计算面积的函数function getArea(width) &#123; return height =&#123; return width * height &#125;&#125;const getTenWidthArea = getArea(10)// 之后碰到宽度为10的长方形就可以这样计算面积const area1 = getTenWidthArea(20)// 而且如果遇到宽度偶尔变化也可以轻松复用const getTwentyWidthArea = getArea(20) 使用闭包模拟私有方法在JavaScript中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法 下面举个例子： 123456789101112131415161718192021222324252627var Counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125;&#125;)();var Counter1 = makeCounter();var Counter2 = makeCounter();console.log(Counter1.value()); /* logs 0 */Counter1.increment();Counter1.increment();console.log(Counter1.value()); /* logs 2 */Counter1.decrement();console.log(Counter1.value()); /* logs 1 */console.log(Counter2.value()); /* logs 0 */ 上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式 两个计数器 Counter1 和 Counter2 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量 其他例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期 三、注意事项如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。 原因在于每个对象的创建，方法都会被重新赋值 1234567891011function MyObject(name, message) &#123; this.name = name.toString(); this.message = message.toString(); this.getName = function() &#123; return this.name; &#125;; this.getMessage = function() &#123; return this.message; &#125;;&#125; 上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下： 12345678910function MyObject(name, message) &#123; this.name = name.toString(); this.message = message.toString();&#125;MyObject.prototype.getName = function() &#123; return this.name;&#125;;MyObject.prototype.getMessage = function() &#123; return this.message;&#125;; 更详细解读点击跳转","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"深拷贝浅拷贝的区别？如何实现一个深拷贝？","slug":"深拷贝浅拷贝的区别？如何实现一个深拷贝？","date":"2021-06-30T15:59:50.000Z","updated":"2021-07-01T16:29:37.987Z","comments":true,"path":"2021/06/30/深拷贝浅拷贝的区别？如何实现一个深拷贝？/","link":"","permalink":"http://xerduo.com/2021/06/30/深拷贝浅拷贝的区别？如何实现一个深拷贝？/","excerpt":"一、数据类型存储JavaScript中存在两大数据类型： 基本类型 引用类型","text":"一、数据类型存储JavaScript中存在两大数据类型： 基本类型 引用类型 基本类型数据保存在在栈内存中 引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中 二、浅拷贝浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址 即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址 下面简单实现一个浅拷贝 123456789function shallowClone(obj) &#123; const newObj = &#123;&#125;; for(let prop in obj) &#123; if(obj.hasOwnProperty(prop))&#123; newObj[prop] = obj[prop]; &#125; &#125; return newObj;&#125; 在JavaScript中，存在浅拷贝的现象有： Object.assign Array.prototype.slice(), Array.prototype.concat() 使用拓展运算符实现的复制 Object.assign123456789101112var obj = &#123; age: 18, nature: ['smart', 'good'], names: &#123; name1: 'fx', name2: 'xka' &#125;, love: function () &#123; console.log('fx is a great girl') &#125;&#125;var newObj = Object.assign(&#123;&#125;, fxObj); slice()12345const fxArr = [\"One\", \"Two\", \"Three\"]const fxArrs = fxArr.slice(0)fxArrs[1] = \"love\";console.log(fxArr) // [\"One\", \"Two\", \"Three\"]console.log(fxArrs) // [\"One\", \"love\", \"Three\"] concat()12345const fxArr = [\"One\", \"Two\", \"Three\"]const fxArrs = fxArr.concat()fxArrs[1] = \"love\";console.log(fxArr) // [\"One\", \"Two\", \"Three\"]console.log(fxArrs) // [\"One\", \"love\", \"Three\"] 拓展运算符12345const fxArr = [\"One\", \"Two\", \"Three\"]const fxArrs = [...fxArr]fxArrs[1] = \"love\";console.log(fxArr) // [\"One\", \"Two\", \"Three\"]console.log(fxArrs) // [\"One\", \"love\", \"Three\"] 三、深拷贝深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性 常见的深拷贝方式有： _.cloneDeep() jQuery.extend() JSON.stringify() 手写循环递归 _.cloneDeep()12345678const _ = require('lodash');const obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;const obj2 = _.cloneDeep(obj1);console.log(obj1.b.f === obj2.b.f);// false jQuery.extend()12345678const $ = require('jquery');const obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;const obj2 = $.extend(true, &#123;&#125;, obj1);console.log(obj1.b.f === obj2.b.f); // false JSON.stringify()1const obj2=JSON.parse(JSON.stringify(obj1)); 但是这种方式存在弊端，会忽略undefined、symbol和函数 12345678const obj = &#123; name: 'A', name1: undefined, name3: function() &#123;&#125;, name4: Symbol('A')&#125;const obj2 = JSON.parse(JSON.stringify(obj));console.log(obj2); // &#123;name: \"A\"&#125; 循环递归123456789101112131415161718192021function deepCopy(obj) &#123; // 如果是null或者undefined我就不进行拷贝操作 if (obj == null) return obj; // 可能是对象或者普通的值 如果是函数的话是不需要深拷贝 if (typeof obj !== \"object\") return obj; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); let newObj = (obj.constructor === Array)? [] : &#123;&#125;; for (let o in obj) &#123; if(obj.hasOwnProperty(o))&#123; // 忽略继承属性 if (typeof obj[o] === 'object') &#123; newObj[o] = deepCopy(obj[o]); &#125; else &#123; newObj[o] = obj[o]; &#125; &#125; &#125; return newObj;&#125; 四、区别下面首先借助两张图，可以更加清晰看到浅拷贝与深拷贝的区别 从上图发现，浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样 浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象 1234567891011// 浅拷贝const obj1 = &#123; name : 'init', arr : [1,[2,3],4],&#125;;const obj3=shallowClone(obj1) // 一个浅拷贝方法obj3.name = \"update\";obj3.arr[1] = [5,6,7] ; // 新旧对象还是共享同一块内存console.log('obj1',obj1) // obj1 &#123; name: 'init', arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;console.log('obj3',obj3) // obj3 &#123; name: 'update', arr: [ 1, [ 5, 6, 7 ], 4 ] &#125; 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象 1234567891011// 深拷贝const obj1 = &#123; name : 'init', arr : [1,[2,3],4],&#125;;const obj4=deepClone(obj1) // 一个深拷贝方法obj4.name = \"update\";obj4.arr[1] = [5,6,7] ; // 新对象跟原对象不共享内存console.log('obj1',obj1) // obj1 &#123; name: 'init', arr: [ 1, [ 2, 3 ], 4 ] &#125;console.log('obj4',obj4) // obj4 &#123; name: 'update', arr: [ 1, [ 5, 6, 7 ], 4 ] &#125; 小结前提为拷贝类型为引用类型的情况下： 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS中两个等号和三个等号的区别","slug":"JS中两个等号和三个等号的区别","date":"2021-06-29T16:28:16.000Z","updated":"2021-06-29T17:05:07.511Z","comments":true,"path":"2021/06/30/JS中两个等号和三个等号的区别/","link":"","permalink":"http://xerduo.com/2021/06/30/JS中两个等号和三个等号的区别/","excerpt":"等于操作符（==）等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 true 前面文章，我们提到在JavaScript中存在隐式转换。等于操作符（==）在比较中会先进行类型转换，再确定操作数是否相等 遵循以下规则： 如果任一操作数是布尔值，则将其转换为数值再比较是否相等","text":"等于操作符（==）等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 true 前面文章，我们提到在JavaScript中存在隐式转换。等于操作符（==）在比较中会先进行类型转换，再确定操作数是否相等 遵循以下规则： 如果任一操作数是布尔值，则将其转换为数值再比较是否相等1let result1 = (true == 1); // true 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等1let result1 = (\"55\" == 55); // true 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法取得其原始值，再根据前面的规则进行比较12let obj = &#123;valueOf:function()&#123;return 1&#125;&#125;let result1 = (obj == 1); // true null 和 undefined相等1let result1 = (null == undefined ); // true 不能转换为其他类型的值再进行比较123false == null // false 0 == null // false false == undefined // false 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true123let obj1 = &#123;name:\"xxx\"&#125;let obj2 = &#123;name:\"xxx\"&#125;let result1 = (obj1 == obj2 ); // false 下面进一步做个小结： 1. 两个都为简单类型，字符串和布尔值都会转换成数值，再比较2. 简单类型与引用类型比较，对象转化成其原始类型的值，再比较3. 两个都为引用类型，则比较它们是否指向同一个对象4. 定义null 和 undefined 相等5. null 和 undefined 不能转换为其他类型的值再进行比较。6. 存在 NaN 则返回 false 全等操作符（===）全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 true。即类型相同，值也需相同12let result1 = (\"55\" === 55); // false，不相等，因为数据类型不同let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同 undefined 和 null 与自身严格相等12let result1 = (null === null) //truelet result2 = (undefined === undefined) //true 区别相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换12let result1 = (\"55\" === 55); // false，不相等，因为数据类型不同let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同 null 和 undefined 比较，相等操作符（==）为true，全等为false12let result1 = (null == undefined ); // truelet result2 = (null === undefined); // false 小结相等运算符隐藏的类型转换，会带来一些违反直觉的结果 '' == '0' // false 类型相同不做类型转换 所以为false 0 == '' // true 0 == Number('') ==&gt; 0 == 0 所以为true 0 == '0' // true 0 == Number('0') ==&gt; 0 == 0 所以为true false == 'false' // false Number(false) == Number('false') ==&gt; 0 == NaN 所以为false false == '0' // true Number(false) == Number('false') ==&gt; 0 == 0 所以为true // null 和 undefined 相等。 // null 和 undefined 不能转换为其他类型的值再进行比较。 false == undefined // false false == null // false null == undefined // true ' \\t\\r\\n' == 0 // true Number(' \\t\\r\\n') == 0 ==&gt; 0 == 0 所以为true 但在比较null的情况的时候，我们一般使用相等操作符== const obj = {}; if(obj.x == null){ console.log(\"1\"); //执行 } 等同于下面写法 if(obj.x === null || obj.x === undefined) { ... } 使用相等操作符（==）的写法明显更加简洁了所以，除了在比较对象属性为null或者undefined的情况下，我们可以使用相等操作符（==），其他情况建议一律使用全等操作符（===）","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS字符串的常用方法","slug":"JS字符串的常用方法","date":"2021-06-29T14:59:18.000Z","updated":"2021-06-29T15:25:34.527Z","comments":true,"path":"2021/06/29/JS字符串的常用方法/","link":"","permalink":"http://xerduo.com/2021/06/29/JS字符串的常用方法/","excerpt":"JS字符串的常用方法常用 操作方法、转换方法、模板匹配方法 操作方法可将字符串常用的操作方法归纳为增、删、改、查，需要知道字符串的特点是一旦创建了，就不可变","text":"JS字符串的常用方法常用 操作方法、转换方法、模板匹配方法 操作方法可将字符串常用的操作方法归纳为增、删、改、查，需要知道字符串的特点是一旦创建了，就不可变 增（常用+以及${}进行字符串拼接之外，还可通过concat）这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作除了常用+以及${}进行字符串拼接之外，还可通过concat1234let stringValue = \"hello \";let result = stringValue.concat(\"world\");console.log(result); // \"hello world\"console.log(stringValue); // \"hello\" 删（slice()、substr()、substring()）这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作常见的有：slice()、substr()、substring()这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。1234567let stringValue = \"hello world\";console.log(stringValue.slice(3)); // \"lo world\"console.log(stringValue.substring(3)); // \"lo world\"console.log(stringValue.substr(3)); // \"lo world\"console.log(stringValue.slice(3, 7)); // \"lo w\"console.log(stringValue.substring(3,7)); // \"lo w\"console.log(stringValue.substr(3, 7)); // \"lo worl\" 特别：从索引3开始截取计数，直到7为止 改这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作常见的有： trim()、trimLeft()、trimRight() repeat() padStart()、padEnd() toLowerCase()、 toUpperCase() trim()、trimLeft()、trimRight()删除前、后或前后所有空格符，再返回新的字符串1234let stringValue = \" hello world \";let trimmedStringValue = stringValue.trim();console.log(stringValue); // \" hello world \"console.log(trimmedStringValue); // \"hello world\" repeat()接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果12let stringValue = \"na \";let copyResult = stringValue.repeat(2) // na na padStart()、padEnd()复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件123let stringValue = \"foo\";console.log(stringValue.padStart(6)); // \" foo\"console.log(stringValue.padStart(9, \".\")); // \"......foo\" toLowerCase()、 toUpperCase()大小写转化123let stringValue = \"hello world\";console.log(stringValue.toUpperCase()); // \"HELLO WORLD\"console.log(stringValue.toLowerCase()); // \"hello world\" 查除了通过索引的方式获取字符串的值，还可通过：chatAt()、indexOf()、startWith()、includes() charAt()返回给定索引位置的字符，由传给方法的整数参数指定12let message = \"abcde\";console.log(message.charAt(2)); // \"c\" indexOf()从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）12let stringValue = \"hello world\";console.log(stringValue.indexOf(\"o\")); // 4 startWith()、includes()从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值12345let message = \"foobarbaz\";console.log(message.startsWith(\"foo\")); // trueconsole.log(message.startsWith(\"bar\")); // falseconsole.log(message.includes(\"bar\")); // trueconsole.log(message.includes(\"qux\")); // false 转换方法split()把字符串按照指定的分割符，拆分成数组中的每一项12let str = \"12+23+34\"let arr = str.split(\"+\") // [12,23,34] 模板匹配方法针对正则表达式，字符串设计了几个方法：match()、search()、replace() match()接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象，返回数组1234let text = \"cat, bat, sat, fat\";let pattern = /.at/;let matches = text.match(pattern);console.log(matches[0]); // \"cat\" search()接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象，找到则返回匹配索引，否则返回 -1123let text = \"cat, bat, sat, fat\";let pos = text.search(/at/);console.log(pos); // 1 replace()接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）123let text = \"cat, bat, sat, fat\";let result = text.replace(\"at\", \"ond\");console.log(result); // \"cond, bat, sat, fat\"","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS数组的常用方法","slug":"JS数组的常用方法","date":"2021-06-29T14:23:53.000Z","updated":"2021-06-29T16:32:26.464Z","comments":true,"path":"2021/06/29/JS数组的常用方法/","link":"","permalink":"http://xerduo.com/2021/06/29/JS数组的常用方法/","excerpt":"JS数组的常用方法操作方法、排序方法、转换方法、迭代方法","text":"JS数组的常用方法操作方法、排序方法、转换方法、迭代方法 操作方法数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会 下面对数组常用的操作方法做一个归纳 增下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响1. push()2. unshift()3. splice()4. concat() push()push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度123let colors = []; // 创建一个数组let count = colors.push(\"red\", \"green\"); // 推入两项console.log(count) // 2 unshift()unshift()在数组开头添加任意多个值，然后返回新的数组长度123let colors = new Array(); // 创建一个数组let count = colors.unshift(\"red\", \"green\"); // 从数组开头推入两项console.log(count); // 2 splice()传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组1234let colors = [\"red\", \"green\", \"blue\"];let removed = colors.splice(1, 0, \"yellow\", \"orange\")console.log(colors) // red,yellow,orange,green,blueconsole.log(removed) // [] concat()首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组1234let colors = [\"red\", \"green\", \"blue\"];let colors2 = colors.concat(\"yellow\", [\"black\", \"brown\"]);console.log(colors); // [\"red\", \"green\",\"blue\"]console.log(colors2); // [\"red\", \"green\", \"blue\", \"yellow\", \"black\", \"brown\"] 删下面三种都会影响原数组，最后一项不影响原数组： pop() shift() splice() slice() pop()pop() 方法用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项1234let colors = [\"red\", \"green\"]let item = colors.pop(); // 取得最后一项console.log(item) // greenconsole.log(colors.length) // 1 shift()shift() 方法用于删除数组的第一项，同时减少数组的 length 值，返回被删除的项1234let colors = [\"red\", \"green\"]let item = colors.shift(); // 取得第一项console.log(item) // redconsole.log(colors.length) // 1 splice()splice() 传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组1234let colors = [\"red\", \"green\", \"blue\"];let removed = colors.splice(0,1); // 删除第一项console.log(colors); // green,blueconsole.log(removed); // red，只有一个元素的数组 slice()slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组123456let colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"];let colors2 = colors.slice(1);let colors3 = colors.slice(1, 4);console.log(colors) // red,green,blue,yellow,purpleconcole.log(colors2); // green,blue,yellow,purpleconcole.log(colors3); // green,blue,yellow 改即修改原来数组的内容，常用splice splice()传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响1234let colors = [\"red\", \"green\", \"blue\"];let removed = colors.splice(1, 1, \"red\", \"purple\"); // 插入两个值，删除一个元素console.log(colors); // red,red,purple,blueconsole.log(removed); // green，只有一个元素的数组 查即查找元素，返回元素坐标或者元素值indexOf()、includes()、find() indexOf()返回要查找的元素在数组中的位置，如果没找到则返回112let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.indexOf(4) // 3 includes()返回要查找的元素在数组中的位置，找到返回true，否则false12let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.includes(4) // true find()返回第一个匹配的元素1234567891011const people = [ &#123; name: \"Matt\", age: 27 &#125;, &#123; name: \"Nicholas\", age: 29 &#125;];people.find((element, index, array) =&gt; element.age &lt; 28) // // &#123;name: \"Matt\", age: 27&#125; 排序方法数组有两个方法可以用来对元素重新排序：reverse()、sort() reverse()顾名思义，将数组元素反方向排列123let values = [1, 2, 3, 4, 5];values.reverse();console.log(values); // 5,4,3,2,1 sort() sort()方法接受一个比较函数，用于判断哪个值应该排在前面123456789101112function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;let values = [0, 1, 5, 10, 15];values.sort(compare);console.log(values); // 0,1,5,10,15 转换方法常见的转换方法有join() join()join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串123let colors = [\"red\", \"green\", \"blue\"];console.log(colors.join(\",\")); // red,green,blueconsole.log(colors.join(\"||\")); // red||green||blue 迭代方法常用来迭代数组的方法（都不改变原数组）有如下：some()、every()、forEach()、filter()、map() some()对数组每一项都运行传入的函数，如果有一项函数返回 true ，则这个方法返回 true123let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let someResult = numbers.every((item, index, array) =&gt; item &gt; 2);console.log(someResult) // true every()对数组每一项都运行传入的函数，如果对每一项函数都返回 true ，则这个方法返回 true123let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2);console.log(everyResult) // false forEach()对数组每一项都运行传入的函数，没有返回值1234let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.forEach((item, index, array) =&gt; &#123; // 执行某些操作&#125;); filter()对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回123let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2);console.log(filterResult); // 3,4,5,4,3 map()对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组123let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let mapResult = numbers.map((item, index, array) =&gt; item * 2);console.log(mapResult) // 2,4,6,8,10,8,6,4,2","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS中的数据类型以及区别","slug":"JS中的数据类型以及区别","date":"2021-06-28T15:34:44.000Z","updated":"2021-06-28T16:25:33.676Z","comments":true,"path":"2021/06/28/JS中的数据类型以及区别/","link":"","permalink":"http://xerduo.com/2021/06/28/JS中的数据类型以及区别/","excerpt":"概述 ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。","text":"概述 ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。但在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型 1let x = y ? 1 : a; 上面代码中，x的值在编译阶段是无法获取的，只有等到程序运行时才能知道 虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制 常见的类型转换有： 强制转换（显示转换） 自动转换（隐式转换） 显示转换显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有： Number() String() Boolean() parseInt() Number()将任意类型的值转化为数值示例： 1234567891011121314151617181920212223Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number('324') // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber('324abc') // NaN// 空字符串转为0Number('') // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0// 对象：通常转换成NaN(除了只包含单个数值的数组)Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5// SymbolNumber(Symbol) // NaNNumber(Symbol()) // Uncaught TypeError: Cannot convert a Symbol value to a number 从上面可以看到，Number转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为NaN parseInt()parseInt相比Number，就没那么严格了，parseInt函数逐个解析字符，遇到不能转换的字符就停下来 1parseInt('32a3') //32 String() 可以将任意类型的值转化成字符串示例： 12345678910111213141516171819 // 数值：转为相应的字符串String(1) // \"1\"//字符串：转换后还是原来的值String(\"a\") // \"a\"//布尔值：true转为字符串\"true\"，false转为字符串\"false\"String(true) // \"true\"//undefined：转为字符串\"undefined\"String(undefined) // \"undefined\"//null：转为字符串\"null\"String(null) // \"null\"//对象String(&#123;a: 1&#125;) // \"[object Object]\"String([1, 2, 3]) // \"1,2,3\"// SymbolString(Symbol()) // \"Symbol()\" String(Symbol) // \"function Symbol() &#123; [native code] &#125;\" Boolean() 可以将任意类型的值转为布尔值 示例：12345678910Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(NaN) // falseBoolean('') // falseBoolean(&#123;&#125;) // trueBoolean([]) // trueBoolean(new Boolean(false)) // trueBoolean(Symbol) // trueBoolean(Symbol()) // true 隐式转换 在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？ 可以归纳为两种情况发生隐式转换的场景： 比较运算（==、!=、&gt;、&lt;）、if、while需要布尔值地方 算术运算（+、-、*、/、%） 除了上面的场景，还要求运算符两边的操作数不是同一类型 自动转换为布尔值在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用Boolean函数 可以得出个小结： undefined null false +0 -0 NaN “”除了上面几种会被转化成false，其他都换被转化成true 自动转换成字符串遇到预期为字符串的地方，就会将非字符串的值自动转为字符串 具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串 常发生在+运算中，一旦存在字符串，则会进行字符串拼接操作12345678'5' + 1 // '51''5' + true // \"5true\"'5' + false // \"5false\"'5' + &#123;&#125; // \"5[object Object]\"'5' + [] // \"5\"'5' + function ()&#123;&#125; // \"5function ()&#123;&#125;\"'5' + undefined // \"5undefined\"'5' + null // \"5null\" 自动转换成数值 除了+有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值 12345678910 '5' - '2' // 3'5' * '2' // 10true - 1 // 0false - 1 // -1'1' - 1 // 0'5' * [] // 0false / '5' // 0'abc' - 1 // NaNnull + 1 // 1undefined + 1 // NaN null转为数值时，值为0 。undefined转为数值时，值为NaN","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"call,apply,bind的用法区别解析","slug":"call,apply,bind的用法区别解析","date":"2021-06-26T09:05:46.000Z","updated":"2021-06-26T11:22:58.896Z","comments":true,"path":"2021/06/26/call,apply,bind的用法区别解析/","link":"","permalink":"http://xerduo.com/2021/06/26/call,apply,bind的用法区别解析/","excerpt":"call、apply、bind异同 由于call()、apply()与bind()都是属于Function.prototype对象下的方法，所以每个function实例都拥有有call、apply与bind属性。 相同点：都是为改变this指向而存在的。 异同点：使用call()方法时，传递给函数的参数必须逐个列举出来，使用apply()方法时，传递给函数的是参数数组。bind()和call()很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。bind()方法不会立即执行，而是返回一个改变了上下文 this后的函数，用于稍后调用。 call()、apply()则是立即调用。","text":"call、apply、bind异同 由于call()、apply()与bind()都是属于Function.prototype对象下的方法，所以每个function实例都拥有有call、apply与bind属性。 相同点：都是为改变this指向而存在的。 异同点：使用call()方法时，传递给函数的参数必须逐个列举出来，使用apply()方法时，传递给函数的是参数数组。bind()和call()很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。bind()方法不会立即执行，而是返回一个改变了上下文 this后的函数，用于稍后调用。 call()、apply()则是立即调用。 这里的this指向window对象 1234funciton foo () &#123; console.log(this); // window对象&#125;foo() // window对象 这里的this指向调用者，谁调用this就指向谁 1234567891011var name = '王小二'var obj = &#123; age:20, name:'张小二', foo:function () &#123; console.log(this.age + '---' + this.name) &#125;&#125;obj.foo() // 20---张小二var fun = obj.foofun() // undefined---王小二 使用call()、apply()、bind()改变this的上下文： 123456789101112let name = '张小二'function foo(sex,age)&#123; console.log(`$&#123;this.name&#125;---$&#123;sex&#125;---$&#123;age&#125;`)&#125;let obj = &#123; name : '王小二'&#125;foo('男',18) // 张小二---男---18foo.call(obj,'男',18) // 王小二---男---18foo.apply(obj,['男',18]) // 王小二---男---18foo.bind(obj,'男',18)() // 王小二---男---18","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS中的new操作符的原理解析","slug":"JS中的new操作符的原理解析","date":"2021-06-25T15:05:12.000Z","updated":"2021-07-10T14:47:20.792Z","comments":true,"path":"2021/06/25/JS中的new操作符的原理解析/","link":"","permalink":"http://xerduo.com/2021/06/25/JS中的new操作符的原理解析/","excerpt":"JS中的new操作符的原理解析JavaScript中new操作符用于创建一个给定构造函数的对象实例。如下例子： 123456function Person(name, age)&#123; this.name = name; this.age = age;&#125;const person1 = new Person('Tom', 20)console.log(person1) // Person &#123;name: \"Tom\", age: 20&#125; 我们定义了一个构造函数Person，然后通过new操作符生成Person构造函数的一个实例并将其引用赋值给变量person1。然后控制台打印出person1的内容，可以看到该实例对象具有name和age属性，它们的值就是我们在调用构造函数时传入的值。 那么，我们使用new操作符的时候都发生了哪些事呢？ new关键字进行的操作new关键字进行了如下的操作（为了便于描述，obj用来表示创建的空对象、用constrc来表示构造函数）： 1、创建一个空对象obj（{}）； 2、将obj的[[prototype]]属性指向构造函数constrc的原型（即obj.[[prototype]] = constrc.prototype）。 3、将构造函数constrc内部的this绑定到新建的对象obj，执行constrc（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.constrc()一样）； 4、若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象obj（默认会添加return this）。否则，返回引用类型的值。 这里补充说明一下：[[prototype]]属性是隐藏的，不过目前大部分新浏览器实现方式是使用__proto__来表示。构造函数的prototype属性我们是可以显式访问的。","text":"JS中的new操作符的原理解析JavaScript中new操作符用于创建一个给定构造函数的对象实例。如下例子： 123456function Person(name, age)&#123; this.name = name; this.age = age;&#125;const person1 = new Person('Tom', 20)console.log(person1) // Person &#123;name: \"Tom\", age: 20&#125; 我们定义了一个构造函数Person，然后通过new操作符生成Person构造函数的一个实例并将其引用赋值给变量person1。然后控制台打印出person1的内容，可以看到该实例对象具有name和age属性，它们的值就是我们在调用构造函数时传入的值。 那么，我们使用new操作符的时候都发生了哪些事呢？ new关键字进行的操作new关键字进行了如下的操作（为了便于描述，obj用来表示创建的空对象、用constrc来表示构造函数）： 1、创建一个空对象obj（{}）； 2、将obj的[[prototype]]属性指向构造函数constrc的原型（即obj.[[prototype]] = constrc.prototype）。 3、将构造函数constrc内部的this绑定到新建的对象obj，执行constrc（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.constrc()一样）； 4、若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象obj（默认会添加return this）。否则，返回引用类型的值。 这里补充说明一下：[[prototype]]属性是隐藏的，不过目前大部分新浏览器实现方式是使用__proto__来表示。构造函数的prototype属性我们是可以显式访问的。让我们用图来展示文章开头的那个例子的过程： ; 自己实现new操作符1234567891011121314151617function myNew(constrc, ...args) &#123; // 1,2 创建一个对象obj，将obj的[[prototype]]属性指向构造函数的原型对象 // 即实现：obj.__proto__ === constructor.prototype const obj = Object.create(constrc.prototype) // 3.将constrc内部的this（即执行上下文）指向obj，并执行 const result = constrc.apply(obj, args); // 4. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象 return result instanceof Object ? result : obj; &#125;// 使用的例子：function Person(name, age)&#123; this.name = name; this.age = age;&#125;const person1 = myNew(Person, 'Tom', 20)console.log(person1) // Person &#123;name: \"Tom\", age: 20&#125; 这里的关键两步就是： 1、将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。2、将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS原型与原型链","slug":"JS原型与原型链","date":"2021-06-20T15:19:26.000Z","updated":"2021-06-28T15:29:12.717Z","comments":true,"path":"2021/06/20/JS原型与原型链/","link":"","permalink":"http://xerduo.com/2021/06/20/JS原型与原型链/","excerpt":"原型和原型链这几个要点是理解原型的关键：1、所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）。2、所有的引用类型都有一个’_ _ proto_ _ ‘属性(也叫隐式原型，它是一个普通的对象)。3、所有的函数都有一个’prototype’属性(这也叫显式原型，它也是一个普通的对象)。4、所有引用类型，它的’_ _ proto_ _’属性指向它的构造函数的’prototype’属性。5、当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _’属性(也就是它的构造函数的’prototype’属性)中去寻找。 原型构造函数的属性prototype,叫做原型,这是可以直接使用的。在JS实例对象中有一个属性 __proto__ ,它也是原型,这是供浏览器使用的,它不是标准的属性。(实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为__proto__)。 实例对象中的__proto__指向的是该实例对象中的构造函数中的prototype，构造函数中的prototype里面的属性或者方法,可以直接通过实例对象调用。 示例：12function Foo() &#123;...&#125;; // 申明构造函数Fooconsole.log( Foo.prototype ); // 打印其prototype属性 控制台输出 123456789101112&#123; constructor: ƒ Foo(), __proto__: &#123; constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125;&#125; 上面这个对象，就是常说的原型对象可以看到，原型对象有一个自有属性constructor，这个属性指向该函数 1Foo.prototype.constructor === Foo // true 原型对象也是一个普通对象，属性__proto__指向其构造函数的原型。1Foo.prototype.__proto__ === Object.prototype // true","text":"原型和原型链这几个要点是理解原型的关键：1、所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）。2、所有的引用类型都有一个’_ _ proto_ _ ‘属性(也叫隐式原型，它是一个普通的对象)。3、所有的函数都有一个’prototype’属性(这也叫显式原型，它也是一个普通的对象)。4、所有引用类型，它的’_ _ proto_ _’属性指向它的构造函数的’prototype’属性。5、当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _’属性(也就是它的构造函数的’prototype’属性)中去寻找。 原型构造函数的属性prototype,叫做原型,这是可以直接使用的。在JS实例对象中有一个属性 __proto__ ,它也是原型,这是供浏览器使用的,它不是标准的属性。(实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为__proto__)。 实例对象中的__proto__指向的是该实例对象中的构造函数中的prototype，构造函数中的prototype里面的属性或者方法,可以直接通过实例对象调用。 示例：12function Foo() &#123;...&#125;; // 申明构造函数Fooconsole.log( Foo.prototype ); // 打印其prototype属性 控制台输出 123456789101112&#123; constructor: ƒ Foo(), __proto__: &#123; constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125;&#125; 上面这个对象，就是常说的原型对象可以看到，原型对象有一个自有属性constructor，这个属性指向该函数 1Foo.prototype.constructor === Foo // true 原型对象也是一个普通对象，属性__proto__指向其构造函数的原型。1Foo.prototype.__proto__ === Object.prototype // true 原型链原型链是一种关系,是实例对象和原型对象之间的关系,这种关系是通过原型(proto)来联系的。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 示例图：12function Foo() &#123;...&#125;; let f1 = new Foo(); 总结 我们需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。 __proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。 prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 参考：帮你彻底搞懂JS中的prototype、_ proto _与constructor（图解）JavaScript原型，原型链 ? 有什么特点？","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"避坑,fill初始化多维数组","slug":"避坑,fill初始化多维数组","date":"2021-05-18T14:39:17.000Z","updated":"2021-06-20T15:19:48.499Z","comments":true,"path":"2021/05/18/避坑,fill初始化多维数组/","link":"","permalink":"http://xerduo.com/2021/05/18/避坑,fill初始化多维数组/","excerpt":"避坑,fill初始化多维数组数组实例的 fill(),使用给定值，填充一个数组。例如： 12let a = new Array(5).fill(0);console.log(a); // 输出结果为[0, 0, 0, 0, 0] 使用fill()创建二维数组12let arr=new Array(3).fill(new Array(3).fill(0))console.log(arr); // 输出结果为[[0,0,0],[0,0,0],[0,0,0]]","text":"避坑,fill初始化多维数组数组实例的 fill(),使用给定值，填充一个数组。例如： 12let a = new Array(5).fill(0);console.log(a); // 输出结果为[0, 0, 0, 0, 0] 使用fill()创建二维数组12let arr=new Array(3).fill(new Array(3).fill(0))console.log(arr); // 输出结果为[[0,0,0],[0,0,0],[0,0,0]] 看似没问题，当给某个元素赋值时如下：每个第一行每一列1的元素的值都改变了。12arr[1][1]=1;console.log(arr) // 输出结果为[[0,1,0],[0,1,0],[0,1,0]] 原因 fill()的参数不是基本类型时，好比数组、对象，并非将它的值填充到数组，而是将它的地址填充到数组，因此填充后数组的每一项都指向的是同一个对象，就会出现”牵一发而动全身”的现象。 解决方法可以使用map遍历123let arr=new Array(3).fill(0).map(item=&gt;new Array(3).fill(0))arr[1][1]=1console.log(arr); // 输出结果为[[0,0,0],[0,1,0],[0,0,0]] 这样就只有arr[1][1]发生改变了。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"forEach、for in 、 for of三者的区别","slug":"forEach,for in,for of三者区别","date":"2021-04-10T02:12:22.000Z","updated":"2021-04-10T03:43:51.996Z","comments":true,"path":"2021/04/10/forEach,for in,for of三者区别/","link":"","permalink":"http://xerduo.com/2021/04/10/forEach,for in,for of三者区别/","excerpt":"for循环除了这三种方法以外还有一种最原始的遍历，它用来遍历数组，for循环中可以使用return、break等来中断循环。","text":"for循环除了这三种方法以外还有一种最原始的遍历，它用来遍历数组，for循环中可以使用return、break等来中断循环。 123456789let arr = [1,2,3]for(let i = 0 ; i&lt; arr.length ; i++)&#123; console.log(arr[i])&#125;/* 输出结果123*/ forEach 对数组的每一个元素执行一次提供的函数（不能使用return、break等中断循环），不改变原数组，无返回值undefined。 123456789let arr = ['a', 'b', 'c']arr.forEach(function (val, index, arr) &#123; // val是当前元素，index当前元素索引，arr数组 console.log(val + ',' + index)&#125;)/* 输出结果a,0b,1c,2*/ for…in循环遍历的值都是数据结构的键值12345let obj = &#123;a: '1', b: '2', c: '3'&#125;for (let o in obj) &#123; console.log(o) //遍历的实际上是对象的属性名称 a,b,c console.log(obj[o]) //这个才是属性对应的值1，2，3&#125; for…in循环有几个缺点。 1、数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。2、for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。12345678910111213Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;;var arr = [3, 5];arr.foo = 'hello';for (var i in arr) &#123; console.log(i);&#125;// 结果是：// 0// 1// foo// arrCustom// objCustom 3、某些情况下，for…in循环会以任意顺序遍历键名。（先把当中的非负整数键提出来，排序好输出，然后将剩下的定义时的顺序输出）4、不可以使用return、break等来中断循环 总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。 for…ofES6中新增加的语法，用来循环获取一对键值对中的值，可以使用return、break等来中断循环 一个数据结构只有部署了 Symbol.iterator 属性, 才具有 iterator接口可以使用 for of循环。例子中的obj对象没有Symbol.iterator属性 所以会报错。 哪些数据结构部署了 Symbol.iteratoer属性了呢? 数组 ArrayMapSetStringarguments对象Nodelist对象, 就是获取的dom列表集合 循环一个数组1234let arr = ['China', 'America', 'Korea']for (let o of arr) &#123; console.log(o) //China, America, Korea&#125; 循环一个普通对象（报错） obj对象没有Symbol.iterator属性 所以会报错。 1234let obj = &#123;a: '1', b: '2', c: '3', d: '4'&#125;for (let o of obj) &#123; console.log(o) // Uncaught TypeError: obj is not iterabl&#125; 如果想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象的 key值集合后,再使用 for of，或者使用内置的Object.values()方法获取对象的value值集合再使用for of。 123456789let obj = &#123;a: '1', b: '2', c: '3', d: '4'&#125;for (let o of Object.keys(obj)) &#123; console.log(o) // a,b,c,d&#125;let obj = &#123;a: '1', b: '2', c: '3', d: '4'&#125;for (let o of Object.values(obj)) &#123; console.log(o) // 1,2,3,4&#125; 循环一个字符串 1234let str = 'love'for (let o of str) &#123; console.log(o) // l,o,v,e&#125; 循环一个Map123456789101112131415let iterable = new Map([[\"a\", 1], [\"b\", 2], [\"c\", 3]]);for (let [key, value] of iterable) &#123; console.log(value);&#125;// 1// 2// 3for (let entry of iterable) &#123; console.log(entry);&#125;// [a, 1]// [b, 2]// [c, 3] 循环一个Set12345678let iterable = new Set([1, 1, 2, 2, 3, 3]);for (let value of iterable) &#123; console.log(value);&#125;// 1// 2// 3","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"函数参数是按值传递的","slug":"函数参数是按值传递的","date":"2021-04-01T14:43:22.000Z","updated":"2021-04-01T14:53:24.298Z","comments":true,"path":"2021/04/01/函数参数是按值传递的/","link":"","permalink":"http://xerduo.com/2021/04/01/函数参数是按值传递的/","excerpt":"函数参数是按值传递的ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。","text":"函数参数是按值传递的ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用 ECMAScript 的话说，就是 arguments 对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。（这在 ECMAScript 中是不可能的。）来看下面这个例子： 12345678 function addTen(num) &#123; num += 10; return num; &#125; let count = 20;let result = addTen(count); console.log(count); // 20，没有变化console.log(result); // 30 这里，函数 addTen()有一个参数 num，它其实是一个局部变量。在调用时，变量 count 作为参数传入。count 的值是 20，这个值被复制到参数 num 以便在 addTen()内部使用。在函数内部，参数 num的值被加上了 10，但这不会影响函数外部的原始变量 count。参数 num 和变量 count 互不干扰，它们只不过碰巧保存了一样的值。如果 num 是按引用传递的，那么 count 的值也会被修改为 30。这个事实在使用数值这样的原始值时是非常明显的。但是，如果变量中传递的是对象，就没那么清楚了。比如，再看这个例子： 123456function setName(obj) &#123; obj.name = \"Nicholas\"; &#125; let person = new Object(); setName(person); console.log(person.name); // \"Nicholas\" 这一次，我们创建了一个对象并把它保存在变量 person 中。然后，这个对象被传给 setName()方法，并被复制到参数 obj 中。在函数内部，obj 和 person 都指向同一个对象。结果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象。当函数内部给 obj 设置了 name 属性时，函数外部的对象也会反映这个变化，因为 obj 指向的对象保存在全局作用域的堆内存上。很多开发者错误地认为，当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子：12345678function setName(obj) &#123; obj.name = \"Nicholas\"; obj = new Object(); obj.name = \"Greg\"; &#125; let person = new Object(); setName(person); console.log(person.name); // \"Nicholas\" 这个例子前后唯一的变化就是 setName()中多了两行代码，将 obj 重新定义为一个有着不同 name的新对象。当 person 传入 setName()时，其 name 属性被设置为”Nicholas”。然后变量 obj 被设置为一个新对象且 name 属性被设置为”Greg”。如果 person 是按引用传递的，那么 person 应该自动将指针改为指向 name 为”Greg”的对象。可是，当我们再次访问 person.name 时，它的值是”Nicholas”，这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。 注意 ECMAScript 中函数的参数就是局部变量。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"前端页面自动渲染AE动画方案","slug":"前端页面自动渲染AE动画方案","date":"2021-03-10T07:57:22.000Z","updated":"2021-03-10T08:38:19.842Z","comments":true,"path":"2021/03/10/前端页面自动渲染AE动画方案/","link":"","permalink":"http://xerduo.com/2021/03/10/前端页面自动渲染AE动画方案/","excerpt":"前端页面自动渲染AE动画方案在项目中，登录页面设计师做了很酷炫的动画效果，开始我们想到的三种实现方式：1、导出GIF图给前端渲染2、导出视频给前端渲染3、导出动画的每一帧图片给前端序列合成动画后来这三种方式因显示效果不好，体积大或者实现复杂等原因被否定了。","text":"前端页面自动渲染AE动画方案在项目中，登录页面设计师做了很酷炫的动画效果，开始我们想到的三种实现方式：1、导出GIF图给前端渲染2、导出视频给前端渲染3、导出动画的每一帧图片给前端序列合成动画后来这三种方式因显示效果不好，体积大或者实现复杂等原因被否定了。 调研经调研发现 Lottie是可应用于Android, iOS, Web和Windows的库，通过Bodymovin解析AE动画，并导出可在移动端和web端渲染动画的json文件。换言之，设计师用AE把动画效果做出来，再用Bodymovin导出相应地json文件给到前端，前端使用Lottie库就可以实现动画效果，如下图: 设计师安装与使用Bodymovin1、关闭AE2、下载并安装ZXP installer https://aescripts.com/learn/zxp-installer/3、下载最新版bodymovin插件 https://github.com/airbnb/lottie-web/blob/master/build/extension/bodymovin.zxp4、把下载好的bodymovin.zxp拖到ZXP installer5、打开AE，在菜单首选项-&gt;常规中勾选☑️允许脚本写入文件和访问网络（否则输出JSON文件时会失败）6、在AE中制作动画，打开菜单窗口-&gt;拓展-&gt;Bodymovin，勾选要输出的动画，并设置输出文件目录，点击render打开输出目录会看到生成的JSON文件，若动画里导入了外部图片，则会在images中存放JSON中引用的图片 前端安装与使用lottie1、安装依赖 npm install lottie-web2、调用 lottie // 引入lottie import lottie from 'lottie-web'; /* */ // 使用 this.animation = lottie.loadAnimation({ container: this.$refs.loginContent, renderer: 'svg', loop: true, autoplay: true, animationData: loginJson, assetsPath: '/static/animation/login/', }); loadAnimation参数 参数 释义 container 用于渲染动画的HTML元素，需确保在调用loadAnimation时该元素已存在 renderer 渲染器，可选值为’svg’（默认值）/‘canvas’/‘html’。 loop 默认值为true。可传递需要循环的特定次数 autoplay 自动播放 path JSON文件路径 animationData JSON数据，与path互斥 name 传递该参数后，可在之后通过lottie命令引用该动画实例 rendererSettings 可传递给renderer实例的特定设置，具体可看 （renderer html的性能更好且支持3d图层） 调试由于创建Lottie动画和平常制作AE动画有所不同，设计师和前端之间有个动画效果联调的过程，为了提高联调效率，设计师可先进行初步的效果预览，再把文件交付给前端。 预览方法1、渲染前设置所要渲染的文件 2、勾选☑️Demo选项 在输出的文件目录中就可找到可预览的html文件 设计师注意事项 对设计师而言，创建Lottie动画和往常制作AE动画有所不同，此文档 (https://airbnb.io/lottie/#/supported-features) 记录了Bodymovin支持输出的AE功能列表，动画制作前需跟设计师沟通好，根据动画加载平台来确认可使用的AE功能。 除此之外，尽量遵循官方文档里对设计过程的指导和建议：1、动画简单化。 创建动画时需时刻记着保持JSON文件的精简，比如尽可能地绑定父子关系，在相似的图层上复制相同的关键帧会增加额外的代码，尽量不使用占用空间最多的路径关键帧动画。诸如自动跟踪描绘、颤动之类的技术会使得JSON文件变得非常大且耗性能。 2、建立形状图层。将AI、EPS、SVG和PDF等资源转换成形状图层否则无法在Lottie中正常使用，转换好后注意删除该资源以防被导出到JSON文件。 3、设置尺寸。在AE中可设置合成尺寸为任意大小，但需确保导出时合成尺寸和资源尺寸大小保持一致。 4、不使用表达式和特效。Lottie暂不支持。 5、注意遮罩尺寸。若使用alpha遮罩，遮照的大小会对性能产生很大的影响。尽可能地把遮罩尺寸维持到最小。 6、动画调试。若输出动画破损，通过每次导出特定图层来调试出哪些图层出了问题。然后在github中附上该图层文件提交问题，选择用其他方式重构该图层。 7、不使用混合模式和亮度蒙版。 8、不添加图层样式。 9、全屏动画。设置比想要支持的最宽屏幕更宽的导出尺寸。 10、设置空白对象。若使用空白对象，需确保勾选可见并设置透明度为0%否则不会被导出到JSON文件。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"Windows结束某个端口的进程","slug":"Windows结束某个端口的进程","date":"2021-03-08T13:04:12.000Z","updated":"2021-03-08T13:22:56.250Z","comments":true,"path":"2021/03/08/Windows结束某个端口的进程/","link":"","permalink":"http://xerduo.com/2021/03/08/Windows结束某个端口的进程/","excerpt":"Windows结束某个端口的进程以8080端口号为例1.打开cmd命令窗口，输入命令：1netstat -ano | findstr 8080 根据端口号查找对应的PID。发现8080端口被PID（进程号）为2188的进程占用。","text":"Windows结束某个端口的进程以8080端口号为例1.打开cmd命令窗口，输入命令：1netstat -ano | findstr 8080 根据端口号查找对应的PID。发现8080端口被PID（进程号）为2188的进程占用。2.根据PID找进程名称，输入命令：1tasklist | findstr 2181 发现是占用8080端口的进程为：javaw.exe。 3.根据PID结束对应进程。输入命令：1taskkill -PID 2188 -F 强制关闭PID为2188的进程。","categories":[{"name":"Windows","slug":"Windows","permalink":"http://xerduo.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://xerduo.com/tags/Windows/"}]},{"title":"JS类型检测","slug":"JS类型检测","date":"2021-03-08T08:51:08.000Z","updated":"2021-03-08T13:17:41.620Z","comments":true,"path":"2021/03/08/JS类型检测/","link":"","permalink":"http://xerduo.com/2021/03/08/JS类型检测/","excerpt":"JS类型检测在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示： 基本类型：String、Number、Boolean、Symbol、Undefined、Null引用类型：Object 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。 鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，不同的方法得到的结果参差不齐。 下面介绍常用的4种方法，并对各个方法存在的问题进行简单的分析。","text":"JS类型检测在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示： 基本类型：String、Number、Boolean、Symbol、Undefined、Null引用类型：Object 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。 鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，不同的方法得到的结果参差不齐。 下面介绍常用的4种方法，并对各个方法存在的问题进行简单的分析。 typeof 1234567891011console.log(typeof \"\"); // string 有效console.log(typeof 1); // number 有效console.log(typeof Symbol()); // symbol 有效console.log(typeof true); // boolean 有效console.log(typeof undefined); // undefined 有效console.log(typeof null); // object 有效console.log(typeof []); // object 有效console.log(typeof function()&#123;&#125;); // function 有效console.log(typeof &#123;&#125;); // objectconsole.log(typeof new Date()); // objectconsole.log(typeof new RegExp()); // object 有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值： 对于基本类型，除 null 以外，均可以返回正确的结果。 对于引用类型，除 function 以外，一律返回 object 类型。 对于 null ，返回 object 类型。 对于 function 返回 function 类型。其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。 instanceofinstanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，我们用一段伪代码来模拟其内部执行过程： constructorObject.prototype.toString.call()toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。 12345678910111213Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ;// [object Boolean]Object.prototype.toString.call(Symbol());//[object Symbol]Object.prototype.toString.call(undefined) ;// [object Undefined]Object.prototype.toString.call(null) ;// [object Null]Object.prototype.toString.call(newFunction()) ;// [object Function]Object.prototype.toString.call(newDate()) ;// [object Date]Object.prototype.toString.call([]) ;// [object Array]Object.prototype.toString.call(newRegExp()) ;// [object RegExp]Object.prototype.toString.call(newError()) ;// [object Error]Object.prototype.toString.call(document) ;// [object HTMLDocument]Object.prototype.toString.call(window) ;//[object global] window 是全局对象 global 的引用","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"null与undefined","slug":"null与undefined","date":"2021-03-08T02:50:11.000Z","updated":"2021-04-01T15:06:02.818Z","comments":true,"path":"2021/03/08/null与undefined/","link":"","permalink":"http://xerduo.com/2021/03/08/null与undefined/","excerpt":"undefined与null ECMAScript 的原始类型中，是有Undefined 和 Null 类型的。 这两种类型都分别对应了属于自己的唯一专用值，即undefined 和 null。 ECMAScript 有 6 种简单数据类型（也称为原始类型）： Undefined、Null、Boolean、Number、String 和 Symbol 。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。","text":"undefined与null ECMAScript 的原始类型中，是有Undefined 和 Null 类型的。 这两种类型都分别对应了属于自己的唯一专用值，即undefined 和 null。 ECMAScript 有 6 种简单数据类型（也称为原始类型）： Undefined、Null、Boolean、Number、String 和 Symbol 。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义（1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined 主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为 了正式明确空对象指针（null）和未初始化变量的区别。 null Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回”object”的原因：let car = null;console.log(typeof car); // “object”在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用 （1）在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。 // （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。Object.getPrototypeOf(Object.prototype)// null 检测1、可以使用 String()转型函数，它始终会返回表示相应类型值的字符串12String(null) // &apos;null&apos; ,String(undefined) // &apos;undefined&apos; 2、使用 Object.prototype.toString.call(arg)12Object.prototype.toString.call(undefined) ; // &quot;[object Undefined]&quot;Object.prototype.toString.call(null) ; // &quot;[object Null]&quot; 历史原因1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0。 1234Number(null)// 05 + null// 5 但是，JavaScript的设计者Brendan Eich（布兰登·艾克），觉得这样做还不够，有两个原因。 首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象。 其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。 因此，Brendan Eich又设计了一个undefined。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"🎮基于canvas的俄罗斯方块游戏","slug":"基于canvas的俄罗斯方块游戏","date":"2021-01-03T07:00:53.000Z","updated":"2021-03-05T13:58:59.924Z","comments":true,"path":"2021/01/03/基于canvas的俄罗斯方块游戏/","link":"","permalink":"http://xerduo.com/2021/01/03/基于canvas的俄罗斯方块游戏/","excerpt":"演示地址 点击这里 使用方法 12// html部分&lt;div id=\"tetris\"&gt;&lt;/div&gt; 1234// Js部分 var tetris = new Tetris(&#123; id:\"tetris\"&#125;);","text":"演示地址 点击这里 使用方法 12// html部分&lt;div id=\"tetris\"&gt;&lt;/div&gt; 1234// Js部分 var tetris = new Tetris(&#123; id:\"tetris\"&#125;); 界面预览游戏开始 游戏进行中 游戏结束","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://xerduo.com/tags/游戏/"}]}]}