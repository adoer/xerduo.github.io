{"meta":{"title":"小耳朵","subtitle":null,"description":null,"author":"Duer","url":"http://xerduo.com"},"pages":[{"title":"","date":"2021-03-05T13:58:59.927Z","updated":"2021-03-05T13:58:59.927Z","comments":true,"path":"google184e1e684149229c.html","permalink":"http://xerduo.com/google184e1e684149229c.html","excerpt":"","text":"google-site-verification: google184e1e684149229c.html"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2021-03-05T13:58:59.925Z","comments":false,"path":"categories/index.html","permalink":"http://xerduo.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-01-19T06:58:08.000Z","updated":"2021-03-08T13:45:12.295Z","comments":true,"path":"about/index.html","permalink":"http://xerduo.com/about/index.html","excerpt":"","text":"关于我1234567&#123; \"name\": \"Duer\", \"Github\": \"https://github.com/adoer\", \"blog\": \"www.xerduo.com\", \"email\": \"duqingbetter@qq.com\", \"WeChat\": \"duerKing\",&#125;"},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2021-03-05T13:58:59.928Z","comments":true,"path":"tags/index.html","permalink":"http://xerduo.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"谈谈this对象的理解","slug":"谈谈this对象的理解","date":"2021-06-30T16:53:58.000Z","updated":"2021-06-30T16:54:56.891Z","comments":true,"path":"2021/07/01/谈谈this对象的理解/","link":"","permalink":"http://xerduo.com/2021/07/01/谈谈this对象的理解/","excerpt":"一、定义函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别 在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定） this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象","text":"一、定义函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别 在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定） this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象举个例子： 123456789101112131415161718192021222324function baz() &#123; // 当前调用栈是：baz // 因此，当前调用位置是全局作用域 console.log( \"baz\" ); bar(); // &lt;-- bar的调用位置&#125;function bar() &#123; // 当前调用栈是：baz --bar // 因此，当前调用位置在baz中 console.log( \"bar\" ); foo(); // &lt;-- foo的调用位置&#125;function foo() &#123; // 当前调用栈是：baz --bar --foo // 因此，当前调用位置在bar中 console.log( \"foo\" );&#125;baz(); // &lt;-- baz的调用位置 同时，this在函数执行过程中，this一旦被确定了，就不可以再更改 1234567891011var a = 10;var obj = &#123; a: 20&#125;function fn() &#123; this = obj; // 修改this，运行后会报错 console.log(this.a);&#125;fn(); 二、绑定规则根据不同的使用场合，this有不同的值，主要分为下面几种情况： 默认绑定 隐式绑定 new绑定 显示绑定 默认绑定全局环境中定义person函数，内部使用this关键字 12345var name = 'Jenny';function person() &#123; return this.name;&#125;console.log(person()); //Jenny 上述代码输出Jenny，原因是调用函数的对象在游览器中位window，因此this指向window，所以输出Jenny 注意： 严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象 隐式绑定函数还可以作为某个对象的方法调用，这时this就指这个上级对象 123456789function test() &#123; console.log(this.x);&#125;var obj = &#123;&#125;;obj.x = 1;obj.m = test;obj.m(); // 1 这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象 123456789var o = &#123; a:10, b:&#123; fn:function()&#123; console.log(this.a); //undefined &#125; &#125;&#125;o.b.fn(); 上述代码中，this的上一级对象为b，b内部并没有a变量的定义，所以输出undefined 这里再举一种特殊情况 123456789101112var o = &#123; a:10, b:&#123; a:12, fn:function()&#123; console.log(this.a); //undefined console.log(this); //window &#125; &#125;&#125;var j = o.b.fn;j(); 此时this指向的是window，这里的大家需要记住，this永远指向的是最后调用它的对象，虽然fn是对象b的方法，但是fn赋值给j时候并没有执行，所以最终指向window new绑定通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象 123456function test() &#123; this.x = 1;&#125;var obj = new test();obj.x // 1 上述代码之所以能过输出1，是因为new关键字改变了this的指向 这里再列举一些特殊情况： new过程遇到return一个对象，此时this指向为返回的对象 1234567function fn() &#123; this.user = 'xxx'; return &#123;&#125;; &#125;var a = new fn(); console.log(a.user); //undefined 如果返回一个简单类型的时候，则this指向实例对象 1234567function fn() &#123; this.user = 'xxx'; return 1;&#125;var a = new fn; console.log(a.user); //xxx 注意的是null虽然也是对象，但是此时new仍然指向实例对象 1234567function fn() &#123; this.user = 'xxx'; return null;&#125;var a = new fn; console.log(a.user); //xxx 显示修改apply()、call()、bind()是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时this指的就是这第一个参数 123456789var x = 0;function test() &#123; console.log(this.x);&#125;var obj = &#123;&#125;;obj.x = 1;obj.m = test;obj.m.apply(obj) // 1 关于apply、call、bind三者的区别，我们后面再详细说 三、箭头函数在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 this 的指向（编译时绑定） 举个例子： 123456789const obj = &#123; sayThis: () =&#123; console.log(this); &#125;&#125;;obj.sayThis(); // window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了const globalSay = obj.sayThis;globalSay(); // window 浏览器中的 global 对象 虽然箭头函数的this能够在编译的时候就确定了this的指向，但也需要注意一些潜在的坑 下面举个例子： 绑定事件监听 12345const button = document.getElementById('mngb');button.addEventListener('click', ()=&#123; console.log(this === window) // true this.innerHTML = 'clicked button'&#125;) 上述可以看到，我们其实是想要this为点击的button，但此时this指向了window 包括在原型上添加方法时候，此时this指向window 123456Cat.prototype.sayName = () =&#123; console.log(this === window) //true return this.name&#125;const cat = new Cat('mm');cat.sayName() 同样的，箭头函数不能作为构建函数 四、优先级隐式绑定 VS 显式绑定12345678910111213141516171819function foo() &#123; console.log( this.a );&#125;var obj1 = &#123; a: 2, foo: foo&#125;;var obj2 = &#123; a: 3, foo: foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call( obj2 ); // 3obj2.foo.call( obj1 ); // 2 显然，显示绑定的优先级更高 new绑定 VS 隐式绑定12345678910111213141516171819function foo(something) &#123; this.a = something;&#125;var obj1 = &#123; foo: foo&#125;;var obj2 = &#123;&#125;;obj1.foo( 2 );console.log( obj1.a ); // 2obj1.foo.call( obj2, 3 );console.log( obj2.a ); // 3var bar = new obj1.foo( 4 );console.log( obj1.a ); // 2console.log( bar.a ); // 4 可以看到，new绑定的优先级&gt;隐式绑定 new绑定 VS 显式绑定因为new和apply、call无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试 12345678910111213function foo(something) &#123; this.a = something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind( obj1 );bar( 2 );console.log( obj1.a ); // 2var baz = new bar( 3 );console.log( obj1.a ); // 2console.log( baz.a ); // 3 bar被绑定到obj1上，但是new bar(3) 并没有像我们预计的那样把obj1.a修改为3。但是，new修改了绑定调用bar()中的this 我们可认为new绑定优先级&gt;显式绑定 综上，new绑定优先级 显示绑定优先级 隐式绑定优先级 默认绑定优先级 相关链接 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"说说你对作用域链的理解","slug":"说说你对作用域链的理解","date":"2021-06-30T16:51:32.000Z","updated":"2021-07-01T16:55:44.998Z","comments":true,"path":"2021/07/01/说说你对作用域链的理解/","link":"","permalink":"http://xerduo.com/2021/07/01/说说你对作用域链的理解/","excerpt":"一、作用域作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合 换句话说，作用域决定了代码区块中变量和其他资源的可见性","text":"一、作用域作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合 换句话说，作用域决定了代码区块中变量和其他资源的可见性举个例子 12345function myFunction() &#123; let inVariable = \"函数内部变量\";&#125;myFunction();//要先执行这个函数，否则根本不知道里面是啥console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined 上述例子中，函数myFunction内部创建一个inVariable变量，当我们在全局访问这个变量的时候，系统会报错 这就说明我们在全局是无法获取到（闭包除外）函数内部的变量 我们一般将作用域分成： 全局作用域 函数作用域 块级作用域 全局作用域任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问 1234567// 全局变量var greeting = 'Hello World!';function greet() &#123; console.log(greeting);&#125;// 打印 'Hello World!'greet(); 函数作用域函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问 12345678function greet() &#123; var greeting = 'Hello World!'; console.log(greeting);&#125;// 打印 'Hello World!'greet();// 报错： Uncaught ReferenceError: greeting is not definedconsole.log(greeting); 可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域 块级作用域ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量 12345678910&#123; // 块级作用域中的变量 let greeting = 'Hello World!'; var lang = 'English'; console.log(greeting); // Prints 'Hello World!'&#125;// 变量 'English'console.log(lang);// 报错：Uncaught ReferenceError: greeting is not definedconsole.log(greeting); 二、词法作用域词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，JavaScript 遵循的就是词法作用域 123456789var a = 2;function foo()&#123; console.log(a)&#125;function bar()&#123; var a = 3; foo();&#125;bar() 上述代码改变成一张图 由于JavaScript遵循词法作用域，相同层级的 foo 和 bar 就没有办法访问到彼此块作用域中的变量，所以输出2 三、作用域链当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域 如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错 这里拿《你不知道的Javascript(上)》中的一张图解释： 把作用域比喻成一个建筑，这份建筑代表程序中的嵌套作用域链，第一层代表当前的执行作用域，顶层代表全局作用域 变量的引用会顺着当前楼层进行查找，如果找不到，则会往上一层找，一旦到达顶层，查找的过程都会停止 下面代码演示下： 123456789101112var sex = '男';function person() &#123; var name = '张三'; function student() &#123; var age = 18; console.log(name); // 张三 console.log(sex); // 男 &#125; student(); console.log(age); // Uncaught ReferenceError: age is not defined&#125;person(); 上述代码主要主要做了以下工作： student函数内部属于最内层作用域，找不到name，向上一层作用域person函数内部找，找到了输出“张三” student内部输出cat时找不到，向上一层作用域person函数找，还找不到继续向上一层找，即全局作用域，找到了输出“男” 在person函数内部输出age时找不到，向上一层作用域找，即全局作用域，还是找不到则报错","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"对闭包的理解？闭包使用场景","slug":"对闭包的理解？闭包使用场景","date":"2021-06-30T16:15:35.000Z","updated":"2021-06-30T16:21:33.929Z","comments":true,"path":"2021/07/01/对闭包的理解？闭包使用场景/","link":"","permalink":"http://xerduo.com/2021/07/01/对闭包的理解？闭包使用场景/","excerpt":"一、是什么一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）","text":"一、是什么一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域 在 JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁 下面给出一个简单的例子 12345678function init() &#123; var name = \"Mozilla\"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数，一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; displayName();&#125;init(); displayName() 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量 二、使用场景任何闭包的使用场景都离不开这两点： 创建私有变量 延长变量的生命周期 一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的 下面举个例子： 在页面上添加一些可以调整字号的按钮 12345678910111213function makeSizer(size) &#123; return function() &#123; document.body.style.fontSize = size + 'px'; &#125;;&#125;var size12 = makeSizer(12);var size14 = makeSizer(14);var size16 = makeSizer(16);document.getElementById('size-12').onclick = size12;document.getElementById('size-14').onclick = size14;document.getElementById('size-16').onclick = size16; 柯里化函数柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用 12345678910111213141516171819202122// 假设我们有一个求长方形面积的函数function getArea(width, height) &#123; return width * height&#125;// 如果我们碰到的长方形的宽老是10const area1 = getArea(10, 20)const area2 = getArea(10, 30)const area3 = getArea(10, 40)// 我们可以使用闭包柯里化这个计算面积的函数function getArea(width) &#123; return height =&#123; return width * height &#125;&#125;const getTenWidthArea = getArea(10)// 之后碰到宽度为10的长方形就可以这样计算面积const area1 = getTenWidthArea(20)// 而且如果遇到宽度偶尔变化也可以轻松复用const getTwentyWidthArea = getArea(20) 使用闭包模拟私有方法在JavaScript中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法 下面举个例子： 123456789101112131415161718192021222324252627var Counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125;&#125;)();var Counter1 = makeCounter();var Counter2 = makeCounter();console.log(Counter1.value()); /* logs 0 */Counter1.increment();Counter1.increment();console.log(Counter1.value()); /* logs 2 */Counter1.decrement();console.log(Counter1.value()); /* logs 1 */console.log(Counter2.value()); /* logs 0 */ 上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式 两个计数器 Counter1 和 Counter2 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量 其他例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期 三、注意事项如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。 原因在于每个对象的创建，方法都会被重新赋值 1234567891011function MyObject(name, message) &#123; this.name = name.toString(); this.message = message.toString(); this.getName = function() &#123; return this.name; &#125;; this.getMessage = function() &#123; return this.message; &#125;;&#125; 上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下： 12345678910function MyObject(name, message) &#123; this.name = name.toString(); this.message = message.toString();&#125;MyObject.prototype.getName = function() &#123; return this.name;&#125;;MyObject.prototype.getMessage = function() &#123; return this.message;&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"深拷贝浅拷贝的区别？如何实现一个深拷贝？","slug":"深拷贝浅拷贝的区别？如何实现一个深拷贝？","date":"2021-06-30T15:59:50.000Z","updated":"2021-07-01T16:29:37.987Z","comments":true,"path":"2021/06/30/深拷贝浅拷贝的区别？如何实现一个深拷贝？/","link":"","permalink":"http://xerduo.com/2021/06/30/深拷贝浅拷贝的区别？如何实现一个深拷贝？/","excerpt":"一、数据类型存储JavaScript中存在两大数据类型： 基本类型 引用类型","text":"一、数据类型存储JavaScript中存在两大数据类型： 基本类型 引用类型 基本类型数据保存在在栈内存中 引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中 二、浅拷贝浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址 即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址 下面简单实现一个浅拷贝 123456789function shallowClone(obj) &#123; const newObj = &#123;&#125;; for(let prop in obj) &#123; if(obj.hasOwnProperty(prop))&#123; newObj[prop] = obj[prop]; &#125; &#125; return newObj;&#125; 在JavaScript中，存在浅拷贝的现象有： Object.assign Array.prototype.slice(), Array.prototype.concat() 使用拓展运算符实现的复制 Object.assign123456789101112var obj = &#123; age: 18, nature: ['smart', 'good'], names: &#123; name1: 'fx', name2: 'xka' &#125;, love: function () &#123; console.log('fx is a great girl') &#125;&#125;var newObj = Object.assign(&#123;&#125;, fxObj); slice()12345const fxArr = [\"One\", \"Two\", \"Three\"]const fxArrs = fxArr.slice(0)fxArrs[1] = \"love\";console.log(fxArr) // [\"One\", \"Two\", \"Three\"]console.log(fxArrs) // [\"One\", \"love\", \"Three\"] concat()12345const fxArr = [\"One\", \"Two\", \"Three\"]const fxArrs = fxArr.concat()fxArrs[1] = \"love\";console.log(fxArr) // [\"One\", \"Two\", \"Three\"]console.log(fxArrs) // [\"One\", \"love\", \"Three\"] 拓展运算符12345const fxArr = [\"One\", \"Two\", \"Three\"]const fxArrs = [...fxArr]fxArrs[1] = \"love\";console.log(fxArr) // [\"One\", \"Two\", \"Three\"]console.log(fxArrs) // [\"One\", \"love\", \"Three\"] 三、深拷贝深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性 常见的深拷贝方式有： _.cloneDeep() jQuery.extend() JSON.stringify() 手写循环递归 _.cloneDeep()12345678const _ = require('lodash');const obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;const obj2 = _.cloneDeep(obj1);console.log(obj1.b.f === obj2.b.f);// false jQuery.extend()12345678const $ = require('jquery');const obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;const obj2 = $.extend(true, &#123;&#125;, obj1);console.log(obj1.b.f === obj2.b.f); // false JSON.stringify()1const obj2=JSON.parse(JSON.stringify(obj1)); 但是这种方式存在弊端，会忽略undefined、symbol和函数 12345678const obj = &#123; name: 'A', name1: undefined, name3: function() &#123;&#125;, name4: Symbol('A')&#125;const obj2 = JSON.parse(JSON.stringify(obj));console.log(obj2); // &#123;name: \"A\"&#125; 循环递归123456789101112131415161718192021function deepCopy(obj) &#123; // 如果是null或者undefined我就不进行拷贝操作 if (obj == null) return obj; // 可能是对象或者普通的值 如果是函数的话是不需要深拷贝 if (typeof obj !== \"object\") return obj; if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); let newObj = (obj.constructor === Array)? [] : &#123;&#125;; for (let o in obj) &#123; if(obj.hasOwnProperty(o))&#123; // 忽略继承属性 if (typeof obj[o] === 'object') &#123; newObj[o] = deepCopy(obj[o]); &#125; else &#123; newObj[o] = obj[o]; &#125; &#125; &#125; return newObj;&#125; 四、区别下面首先借助两张图，可以更加清晰看到浅拷贝与深拷贝的区别 从上图发现，浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样 浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象 1234567891011// 浅拷贝const obj1 = &#123; name : 'init', arr : [1,[2,3],4],&#125;;const obj3=shallowClone(obj1) // 一个浅拷贝方法obj3.name = \"update\";obj3.arr[1] = [5,6,7] ; // 新旧对象还是共享同一块内存console.log('obj1',obj1) // obj1 &#123; name: 'init', arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;console.log('obj3',obj3) // obj3 &#123; name: 'update', arr: [ 1, [ 5, 6, 7 ], 4 ] &#125; 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象 1234567891011// 深拷贝const obj1 = &#123; name : 'init', arr : [1,[2,3],4],&#125;;const obj4=deepClone(obj1) // 一个深拷贝方法obj4.name = \"update\";obj4.arr[1] = [5,6,7] ; // 新对象跟原对象不共享内存console.log('obj1',obj1) // obj1 &#123; name: 'init', arr: [ 1, [ 2, 3 ], 4 ] &#125;console.log('obj4',obj4) // obj4 &#123; name: 'update', arr: [ 1, [ 5, 6, 7 ], 4 ] &#125; 小结前提为拷贝类型为引用类型的情况下： 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS中两个等号和三个等号的区别","slug":"JS中两个等号和三个等号的区别","date":"2021-06-29T16:28:16.000Z","updated":"2021-06-29T17:05:07.511Z","comments":true,"path":"2021/06/30/JS中两个等号和三个等号的区别/","link":"","permalink":"http://xerduo.com/2021/06/30/JS中两个等号和三个等号的区别/","excerpt":"等于操作符（==）等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 true 前面文章，我们提到在JavaScript中存在隐式转换。等于操作符（==）在比较中会先进行类型转换，再确定操作数是否相等 遵循以下规则： 如果任一操作数是布尔值，则将其转换为数值再比较是否相等","text":"等于操作符（==）等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 true 前面文章，我们提到在JavaScript中存在隐式转换。等于操作符（==）在比较中会先进行类型转换，再确定操作数是否相等 遵循以下规则： 如果任一操作数是布尔值，则将其转换为数值再比较是否相等1let result1 = (true == 1); // true 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等1let result1 = (\"55\" == 55); // true 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法取得其原始值，再根据前面的规则进行比较12let obj = &#123;valueOf:function()&#123;return 1&#125;&#125;let result1 = (obj == 1); // true null 和 undefined相等1let result1 = (null == undefined ); // true 不能转换为其他类型的值再进行比较123false == null // false 0 == null // false false == undefined // false 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true123let obj1 = &#123;name:\"xxx\"&#125;let obj2 = &#123;name:\"xxx\"&#125;let result1 = (obj1 == obj2 ); // false 下面进一步做个小结： 1. 两个都为简单类型，字符串和布尔值都会转换成数值，再比较2. 简单类型与引用类型比较，对象转化成其原始类型的值，再比较3. 两个都为引用类型，则比较它们是否指向同一个对象4. 定义null 和 undefined 相等5. null 和 undefined 不能转换为其他类型的值再进行比较。6. 存在 NaN 则返回 false 全等操作符（===）全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 true。即类型相同，值也需相同12let result1 = (\"55\" === 55); // false，不相等，因为数据类型不同let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同 undefined 和 null 与自身严格相等12let result1 = (null === null) //truelet result2 = (undefined === undefined) //true 区别相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换12let result1 = (\"55\" === 55); // false，不相等，因为数据类型不同let result2 = (55 === 55); // true，相等，因为数据类型相同值也相同 null 和 undefined 比较，相等操作符（==）为true，全等为false12let result1 = (null == undefined ); // truelet result2 = (null === undefined); // false 小结相等运算符隐藏的类型转换，会带来一些违反直觉的结果 '' == '0' // false 类型相同不做类型转换 所以为false 0 == '' // true 0 == Number('') ==&gt; 0 == 0 所以为true 0 == '0' // true 0 == Number('0') ==&gt; 0 == 0 所以为true false == 'false' // false Number(false) == Number('false') ==&gt; 0 == NaN 所以为false false == '0' // true Number(false) == Number('false') ==&gt; 0 == 0 所以为true // null 和 undefined 相等。 // null 和 undefined 不能转换为其他类型的值再进行比较。 false == undefined // false false == null // false null == undefined // true ' \\t\\r\\n' == 0 // true Number(' \\t\\r\\n') == 0 ==&gt; 0 == 0 所以为true 但在比较null的情况的时候，我们一般使用相等操作符== const obj = {}; if(obj.x == null){ console.log(\"1\"); //执行 } 等同于下面写法 if(obj.x === null || obj.x === undefined) { ... } 使用相等操作符（==）的写法明显更加简洁了所以，除了在比较对象属性为null或者undefined的情况下，我们可以使用相等操作符（==），其他情况建议一律使用全等操作符（===）","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS字符串的常用方法","slug":"JS字符串的常用方法","date":"2021-06-29T14:59:18.000Z","updated":"2021-06-29T15:25:34.527Z","comments":true,"path":"2021/06/29/JS字符串的常用方法/","link":"","permalink":"http://xerduo.com/2021/06/29/JS字符串的常用方法/","excerpt":"JS字符串的常用方法常用 操作方法、转换方法、模板匹配方法 操作方法可将字符串常用的操作方法归纳为增、删、改、查，需要知道字符串的特点是一旦创建了，就不可变","text":"JS字符串的常用方法常用 操作方法、转换方法、模板匹配方法 操作方法可将字符串常用的操作方法归纳为增、删、改、查，需要知道字符串的特点是一旦创建了，就不可变 增（常用+以及${}进行字符串拼接之外，还可通过concat）这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作除了常用+以及${}进行字符串拼接之外，还可通过concat1234let stringValue = \"hello \";let result = stringValue.concat(\"world\");console.log(result); // \"hello world\"console.log(stringValue); // \"hello\" 删（slice()、substr()、substring()）这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作常见的有：slice()、substr()、substring()这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。1234567let stringValue = \"hello world\";console.log(stringValue.slice(3)); // \"lo world\"console.log(stringValue.substring(3)); // \"lo world\"console.log(stringValue.substr(3)); // \"lo world\"console.log(stringValue.slice(3, 7)); // \"lo w\"console.log(stringValue.substring(3,7)); // \"lo w\"console.log(stringValue.substr(3, 7)); // \"lo worl\" 特别：从索引3开始截取计数，直到7为止 改这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作常见的有： trim()、trimLeft()、trimRight() repeat() padStart()、padEnd() toLowerCase()、 toUpperCase() trim()、trimLeft()、trimRight()删除前、后或前后所有空格符，再返回新的字符串1234let stringValue = \" hello world \";let trimmedStringValue = stringValue.trim();console.log(stringValue); // \" hello world \"console.log(trimmedStringValue); // \"hello world\" repeat()接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果12let stringValue = \"na \";let copyResult = stringValue.repeat(2) // na na padStart()、padEnd()复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件123let stringValue = \"foo\";console.log(stringValue.padStart(6)); // \" foo\"console.log(stringValue.padStart(9, \".\")); // \"......foo\" toLowerCase()、 toUpperCase()大小写转化123let stringValue = \"hello world\";console.log(stringValue.toUpperCase()); // \"HELLO WORLD\"console.log(stringValue.toLowerCase()); // \"hello world\" 查除了通过索引的方式获取字符串的值，还可通过：chatAt()、indexOf()、startWith()、includes() charAt()返回给定索引位置的字符，由传给方法的整数参数指定12let message = \"abcde\";console.log(message.charAt(2)); // \"c\" indexOf()从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）12let stringValue = \"hello world\";console.log(stringValue.indexOf(\"o\")); // 4 startWith()、includes()从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值12345let message = \"foobarbaz\";console.log(message.startsWith(\"foo\")); // trueconsole.log(message.startsWith(\"bar\")); // falseconsole.log(message.includes(\"bar\")); // trueconsole.log(message.includes(\"qux\")); // false 转换方法split()把字符串按照指定的分割符，拆分成数组中的每一项12let str = \"12+23+34\"let arr = str.split(\"+\") // [12,23,34] 模板匹配方法针对正则表达式，字符串设计了几个方法：match()、search()、replace() match()接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象，返回数组1234let text = \"cat, bat, sat, fat\";let pattern = /.at/;let matches = text.match(pattern);console.log(matches[0]); // \"cat\" search()接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象，找到则返回匹配索引，否则返回 -1123let text = \"cat, bat, sat, fat\";let pos = text.search(/at/);console.log(pos); // 1 replace()接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）123let text = \"cat, bat, sat, fat\";let result = text.replace(\"at\", \"ond\");console.log(result); // \"cond, bat, sat, fat\"","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS数组的常用方法","slug":"JS数组的常用方法","date":"2021-06-29T14:23:53.000Z","updated":"2021-06-29T16:32:26.464Z","comments":true,"path":"2021/06/29/JS数组的常用方法/","link":"","permalink":"http://xerduo.com/2021/06/29/JS数组的常用方法/","excerpt":"JS数组的常用方法操作方法、排序方法、转换方法、迭代方法","text":"JS数组的常用方法操作方法、排序方法、转换方法、迭代方法 操作方法数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会 下面对数组常用的操作方法做一个归纳 增下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响1. push()2. unshift()3. splice()4. concat() push()push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度123let colors = []; // 创建一个数组let count = colors.push(\"red\", \"green\"); // 推入两项console.log(count) // 2 unshift()unshift()在数组开头添加任意多个值，然后返回新的数组长度123let colors = new Array(); // 创建一个数组let count = colors.unshift(\"red\", \"green\"); // 从数组开头推入两项console.log(count); // 2 splice()传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组1234let colors = [\"red\", \"green\", \"blue\"];let removed = colors.splice(1, 0, \"yellow\", \"orange\")console.log(colors) // red,yellow,orange,green,blueconsole.log(removed) // [] concat()首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组1234let colors = [\"red\", \"green\", \"blue\"];let colors2 = colors.concat(\"yellow\", [\"black\", \"brown\"]);console.log(colors); // [\"red\", \"green\",\"blue\"]console.log(colors2); // [\"red\", \"green\", \"blue\", \"yellow\", \"black\", \"brown\"] 删下面三种都会影响原数组，最后一项不影响原数组： pop() shift() splice() slice() pop()pop() 方法用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项1234let colors = [\"red\", \"green\"]let item = colors.pop(); // 取得最后一项console.log(item) // greenconsole.log(colors.length) // 1 shift()shift() 方法用于删除数组的第一项，同时减少数组的 length 值，返回被删除的项1234let colors = [\"red\", \"green\"]let item = colors.shift(); // 取得第一项console.log(item) // redconsole.log(colors.length) // 1 splice()splice() 传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组1234let colors = [\"red\", \"green\", \"blue\"];let removed = colors.splice(0,1); // 删除第一项console.log(colors); // green,blueconsole.log(removed); // red，只有一个元素的数组 slice()slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组123456let colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"];let colors2 = colors.slice(1);let colors3 = colors.slice(1, 4);console.log(colors) // red,green,blue,yellow,purpleconcole.log(colors2); // green,blue,yellow,purpleconcole.log(colors3); // green,blue,yellow 改即修改原来数组的内容，常用splice splice()传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响1234let colors = [\"red\", \"green\", \"blue\"];let removed = colors.splice(1, 1, \"red\", \"purple\"); // 插入两个值，删除一个元素console.log(colors); // red,red,purple,blueconsole.log(removed); // green，只有一个元素的数组 查即查找元素，返回元素坐标或者元素值indexOf()、includes()、find() indexOf()返回要查找的元素在数组中的位置，如果没找到则返回112let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.indexOf(4) // 3 includes()返回要查找的元素在数组中的位置，找到返回true，否则false12let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.includes(4) // true find()返回第一个匹配的元素1234567891011const people = [ &#123; name: \"Matt\", age: 27 &#125;, &#123; name: \"Nicholas\", age: 29 &#125;];people.find((element, index, array) =&gt; element.age &lt; 28) // // &#123;name: \"Matt\", age: 27&#125; 排序方法数组有两个方法可以用来对元素重新排序：reverse()、sort() reverse()顾名思义，将数组元素反方向排列123let values = [1, 2, 3, 4, 5];values.reverse();console.log(values); // 5,4,3,2,1 sort() sort()方法接受一个比较函数，用于判断哪个值应该排在前面123456789101112function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;let values = [0, 1, 5, 10, 15];values.sort(compare);console.log(values); // 0,1,5,10,15 转换方法常见的转换方法有join() join()join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串123let colors = [\"red\", \"green\", \"blue\"];console.log(colors.join(\",\")); // red,green,blueconsole.log(colors.join(\"||\")); // red||green||blue 迭代方法常用来迭代数组的方法（都不改变原数组）有如下：some()、every()、forEach()、filter()、map() some()对数组每一项都运行传入的函数，如果有一项函数返回 true ，则这个方法返回 true123let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let someResult = numbers.every((item, index, array) =&gt; item &gt; 2);console.log(someResult) // true every()对数组每一项都运行传入的函数，如果对每一项函数都返回 true ，则这个方法返回 true123let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2);console.log(everyResult) // false forEach()对数组每一项都运行传入的函数，没有返回值1234let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.forEach((item, index, array) =&gt; &#123; // 执行某些操作&#125;); filter()对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回123let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2);console.log(filterResult); // 3,4,5,4,3 map()对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组123let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];let mapResult = numbers.map((item, index, array) =&gt; item * 2);console.log(mapResult) // 2,4,6,8,10,8,6,4,2","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS中的数据类型以及区别","slug":"JS中的数据类型以及区别","date":"2021-06-28T15:34:44.000Z","updated":"2021-06-28T16:25:33.676Z","comments":true,"path":"2021/06/28/JS中的数据类型以及区别/","link":"","permalink":"http://xerduo.com/2021/06/28/JS中的数据类型以及区别/","excerpt":"概述 ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。","text":"概述 ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String 和 Symbol。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。但在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型 1let x = y ? 1 : a; 上面代码中，x的值在编译阶段是无法获取的，只有等到程序运行时才能知道 虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制 常见的类型转换有： 强制转换（显示转换） 自动转换（隐式转换） 显示转换显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有： Number() String() Boolean() parseInt() Number()将任意类型的值转化为数值示例： 1234567891011121314151617181920212223Number(324) // 324// 字符串：如果可以被解析为数值，则转换为相应的数值Number('324') // 324// 字符串：如果不可以被解析为数值，返回 NaNNumber('324abc') // NaN// 空字符串转为0Number('') // 0// 布尔值：true 转成 1，false 转成 0Number(true) // 1Number(false) // 0// undefined：转成 NaNNumber(undefined) // NaN// null：转成0Number(null) // 0// 对象：通常转换成NaN(除了只包含单个数值的数组)Number(&#123;a: 1&#125;) // NaNNumber([1, 2, 3]) // NaNNumber([5]) // 5// SymbolNumber(Symbol) // NaNNumber(Symbol()) // Uncaught TypeError: Cannot convert a Symbol value to a number 从上面可以看到，Number转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为NaN parseInt()parseInt相比Number，就没那么严格了，parseInt函数逐个解析字符，遇到不能转换的字符就停下来 1parseInt('32a3') //32 String() 可以将任意类型的值转化成字符串示例： 12345678910111213141516171819 // 数值：转为相应的字符串String(1) // \"1\"//字符串：转换后还是原来的值String(\"a\") // \"a\"//布尔值：true转为字符串\"true\"，false转为字符串\"false\"String(true) // \"true\"//undefined：转为字符串\"undefined\"String(undefined) // \"undefined\"//null：转为字符串\"null\"String(null) // \"null\"//对象String(&#123;a: 1&#125;) // \"[object Object]\"String([1, 2, 3]) // \"1,2,3\"// SymbolString(Symbol()) // \"Symbol()\" String(Symbol) // \"function Symbol() &#123; [native code] &#125;\" Boolean() 可以将任意类型的值转为布尔值 示例：12345678910Boolean(undefined) // falseBoolean(null) // falseBoolean(0) // falseBoolean(NaN) // falseBoolean('') // falseBoolean(&#123;&#125;) // trueBoolean([]) // trueBoolean(new Boolean(false)) // trueBoolean(Symbol) // trueBoolean(Symbol()) // true 隐式转换 在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？ 可以归纳为两种情况发生隐式转换的场景： 比较运算（==、!=、&gt;、&lt;）、if、while需要布尔值地方 算术运算（+、-、*、/、%） 除了上面的场景，还要求运算符两边的操作数不是同一类型 自动转换为布尔值在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用Boolean函数 可以得出个小结： undefined null false +0 -0 NaN “”除了上面几种会被转化成false，其他都换被转化成true 自动转换成字符串遇到预期为字符串的地方，就会将非字符串的值自动转为字符串 具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串 常发生在+运算中，一旦存在字符串，则会进行字符串拼接操作12345678'5' + 1 // '51''5' + true // \"5true\"'5' + false // \"5false\"'5' + &#123;&#125; // \"5[object Object]\"'5' + [] // \"5\"'5' + function ()&#123;&#125; // \"5function ()&#123;&#125;\"'5' + undefined // \"5undefined\"'5' + null // \"5null\" 自动转换成数值 除了+有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值 12345678910 '5' - '2' // 3'5' * '2' // 10true - 1 // 0false - 1 // -1'1' - 1 // 0'5' * [] // 0false / '5' // 0'abc' - 1 // NaNnull + 1 // 1undefined + 1 // NaN null转为数值时，值为0 。undefined转为数值时，值为NaN","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"call,apply,bind的用法区别解析","slug":"call,apply,bind的用法区别解析","date":"2021-06-26T09:05:46.000Z","updated":"2021-06-26T11:22:58.896Z","comments":true,"path":"2021/06/26/call,apply,bind的用法区别解析/","link":"","permalink":"http://xerduo.com/2021/06/26/call,apply,bind的用法区别解析/","excerpt":"call、apply、bind异同 由于call()、apply()与bind()都是属于Function.prototype对象下的方法，所以每个function实例都拥有有call、apply与bind属性。 相同点：都是为改变this指向而存在的。 异同点：使用call()方法时，传递给函数的参数必须逐个列举出来，使用apply()方法时，传递给函数的是参数数组。bind()和call()很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。bind()方法不会立即执行，而是返回一个改变了上下文 this后的函数，用于稍后调用。 call()、apply()则是立即调用。","text":"call、apply、bind异同 由于call()、apply()与bind()都是属于Function.prototype对象下的方法，所以每个function实例都拥有有call、apply与bind属性。 相同点：都是为改变this指向而存在的。 异同点：使用call()方法时，传递给函数的参数必须逐个列举出来，使用apply()方法时，传递给函数的是参数数组。bind()和call()很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。bind()方法不会立即执行，而是返回一个改变了上下文 this后的函数，用于稍后调用。 call()、apply()则是立即调用。 这里的this指向window对象 1234funciton foo () &#123; console.log(this); // window对象&#125;foo() // window对象 这里的this指向调用者，谁调用this就指向谁 1234567891011var name = '王小二'var obj = &#123; age:20, name:'张小二', foo:function () &#123; console.log(this.age + '---' + this.name) &#125;&#125;obj.foo() // 20---张小二var fun = obj.foofun() // undefined---王小二 使用call()、apply()、bind()改变this的上下文： 123456789101112let name = '张小二'function foo(sex,age)&#123; console.log(`$&#123;this.name&#125;---$&#123;sex&#125;---$&#123;age&#125;`)&#125;let obj = &#123; name : '王小二'&#125;foo('男',18) // 张小二---男---18foo.call(obj,'男',18) // 王小二---男---18foo.apply(obj,['男',18]) // 王小二---男---18foo.bind(obj,'男',18)() // 王小二---男---18","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JavaScript中的new操作符的原理解析","slug":"JavaScript中的new操作符的原理解析","date":"2021-06-25T15:05:12.000Z","updated":"2021-06-27T05:49:27.355Z","comments":true,"path":"2021/06/25/JavaScript中的new操作符的原理解析/","link":"","permalink":"http://xerduo.com/2021/06/25/JavaScript中的new操作符的原理解析/","excerpt":"JavaScript中的new操作符的原理解析JavaScript中new操作符用于创建一个给定构造函数的对象实例。如下例子： 123456function Person(name, age)&#123; this.name = name; this.age = age;&#125;const person1 = new Person('Tom', 20)console.log(person1) // Person &#123;name: \"Tom\", age: 20&#125; 我们定义了一个构造函数Person，然后通过new操作符生成Person构造函数的一个实例并将其引用赋值给变量person1。然后控制台打印出person1的内容，可以看到该实例对象具有name和age属性，它们的值就是我们在调用构造函数时传入的值。 那么，我们使用new操作符的时候都发生了哪些事呢？ new关键字进行的操作new关键字进行了如下的操作（为了便于描述，obj用来表示创建的空对象、用constrc来表示构造函数）： 1、创建一个空对象obj（{}）；2、将obj的[[prototype]]属性指向构造函数constrc的原型（即obj.[[prototype]] = constrc.prototype）。3、将构造函数constrc内部的this绑定到新建的对象obj，执行constrc（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.constrc()一样）；4、若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象obj（默认会添加return this）。否则，返回引用类型的值。这里补充说明一下：[[prototype]]属性是隐藏的，不过目前大部分新浏览器实现方式是使用__proto__来表示。构造函数的prototype属性我们是可以显式访问的。","text":"JavaScript中的new操作符的原理解析JavaScript中new操作符用于创建一个给定构造函数的对象实例。如下例子： 123456function Person(name, age)&#123; this.name = name; this.age = age;&#125;const person1 = new Person('Tom', 20)console.log(person1) // Person &#123;name: \"Tom\", age: 20&#125; 我们定义了一个构造函数Person，然后通过new操作符生成Person构造函数的一个实例并将其引用赋值给变量person1。然后控制台打印出person1的内容，可以看到该实例对象具有name和age属性，它们的值就是我们在调用构造函数时传入的值。 那么，我们使用new操作符的时候都发生了哪些事呢？ new关键字进行的操作new关键字进行了如下的操作（为了便于描述，obj用来表示创建的空对象、用constrc来表示构造函数）： 1、创建一个空对象obj（{}）；2、将obj的[[prototype]]属性指向构造函数constrc的原型（即obj.[[prototype]] = constrc.prototype）。3、将构造函数constrc内部的this绑定到新建的对象obj，执行constrc（也就是跟调用普通函数一样，只是此时函数的this为新创建的对象obj而已，就好像执行obj.constrc()一样）；4、若构造函数没有返回非原始值（即不是引用类型的值），则返回该新建的对象obj（默认会添加return this）。否则，返回引用类型的值。这里补充说明一下：[[prototype]]属性是隐藏的，不过目前大部分新浏览器实现方式是使用__proto__来表示。构造函数的prototype属性我们是可以显式访问的。让我们用图来展示文章开头的那个例子的过程： ; 自己实现new操作符1234567891011121314151617function myNew(constrc, ...args) &#123; // 1,2 创建一个对象obj，将obj的[[prototype]]属性指向构造函数的原型对象 // 即实现：obj.__proto__ === constructor.prototype const obj = Object.create(constrc.prototype) // 3.将constrc内部的this（即执行上下文）指向obj，并执行 const result = constrc.apply(obj, args); // 4. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象 return result instanceof Object ? result : obj; &#125;// 使用的例子：function Person(name, age)&#123; this.name = name; this.age = age;&#125;const person1 = myNew(Person, 'Tom', 20)console.log(person1) // Person &#123;name: \"Tom\", age: 20&#125; 这里的关键两步就是： 1、将新创建对象的原型链设置正确，这样我们才能使用原型链上的方法。2、将新创建的对象作为构造函数执行的上下文，这样我们才能正确地进行一些初始化操作。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"JS原型与原型链","slug":"JS原型与原型链","date":"2021-06-20T15:19:26.000Z","updated":"2021-06-28T15:29:12.717Z","comments":true,"path":"2021/06/20/JS原型与原型链/","link":"","permalink":"http://xerduo.com/2021/06/20/JS原型与原型链/","excerpt":"原型和原型链这几个要点是理解原型的关键：1、所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）。2、所有的引用类型都有一个’_ _ proto_ _ ‘属性(也叫隐式原型，它是一个普通的对象)。3、所有的函数都有一个’prototype’属性(这也叫显式原型，它也是一个普通的对象)。4、所有引用类型，它的’_ _ proto_ _’属性指向它的构造函数的’prototype’属性。5、当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _’属性(也就是它的构造函数的’prototype’属性)中去寻找。 原型构造函数的属性prototype,叫做原型,这是可以直接使用的。在JS实例对象中有一个属性 __proto__ ,它也是原型,这是供浏览器使用的,它不是标准的属性。(实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为__proto__)。 实例对象中的__proto__指向的是该实例对象中的构造函数中的prototype，构造函数中的prototype里面的属性或者方法,可以直接通过实例对象调用。 示例：12function Foo() &#123;...&#125;; // 申明构造函数Fooconsole.log( Foo.prototype ); // 打印其prototype属性 控制台输出 123456789101112&#123; constructor: ƒ Foo(), __proto__: &#123; constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125;&#125; 上面这个对象，就是常说的原型对象可以看到，原型对象有一个自有属性constructor，这个属性指向该函数 1Foo.prototype.constructor === Foo // true 原型对象也是一个普通对象，属性__proto__指向其构造函数的原型。1Foo.prototype.__proto__ === Object.prototype // true","text":"原型和原型链这几个要点是理解原型的关键：1、所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）。2、所有的引用类型都有一个’_ _ proto_ _ ‘属性(也叫隐式原型，它是一个普通的对象)。3、所有的函数都有一个’prototype’属性(这也叫显式原型，它也是一个普通的对象)。4、所有引用类型，它的’_ _ proto_ _’属性指向它的构造函数的’prototype’属性。5、当试图得到一个对象的属性时，如果这个对象本身不存在这个属性，那么就会去它的’_ _ proto_ _’属性(也就是它的构造函数的’prototype’属性)中去寻找。 原型构造函数的属性prototype,叫做原型,这是可以直接使用的。在JS实例对象中有一个属性 __proto__ ,它也是原型,这是供浏览器使用的,它不是标准的属性。(实际上，该属性在ES标准定义中的名字应该是[[Prototype]]，具体实现是由浏览器代理自己实现，谷歌浏览器的实现就是将[[Prototype]]命名为__proto__)。 实例对象中的__proto__指向的是该实例对象中的构造函数中的prototype，构造函数中的prototype里面的属性或者方法,可以直接通过实例对象调用。 示例：12function Foo() &#123;...&#125;; // 申明构造函数Fooconsole.log( Foo.prototype ); // 打印其prototype属性 控制台输出 123456789101112&#123; constructor: ƒ Foo(), __proto__: &#123; constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() &#125;&#125; 上面这个对象，就是常说的原型对象可以看到，原型对象有一个自有属性constructor，这个属性指向该函数 1Foo.prototype.constructor === Foo // true 原型对象也是一个普通对象，属性__proto__指向其构造函数的原型。1Foo.prototype.__proto__ === Object.prototype // true 原型链原型链是一种关系,是实例对象和原型对象之间的关系,这种关系是通过原型(proto)来联系的。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 示例图：12function Foo() &#123;...&#125;; let f1 = new Foo(); 总结 我们需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。 __proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。 prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。 参考：帮你彻底搞懂JS中的prototype、_ proto _与constructor（图解）JavaScript原型，原型链 ? 有什么特点？","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"避坑,fill初始化多维数组","slug":"避坑,fill初始化多维数组","date":"2021-05-18T14:39:17.000Z","updated":"2021-06-20T15:19:48.499Z","comments":true,"path":"2021/05/18/避坑,fill初始化多维数组/","link":"","permalink":"http://xerduo.com/2021/05/18/避坑,fill初始化多维数组/","excerpt":"避坑,fill初始化多维数组数组实例的 fill(),使用给定值，填充一个数组。例如： 12let a = new Array(5).fill(0);console.log(a); // 输出结果为[0, 0, 0, 0, 0] 使用fill()创建二维数组12let arr=new Array(3).fill(new Array(3).fill(0))console.log(arr); // 输出结果为[[0,0,0],[0,0,0],[0,0,0]]","text":"避坑,fill初始化多维数组数组实例的 fill(),使用给定值，填充一个数组。例如： 12let a = new Array(5).fill(0);console.log(a); // 输出结果为[0, 0, 0, 0, 0] 使用fill()创建二维数组12let arr=new Array(3).fill(new Array(3).fill(0))console.log(arr); // 输出结果为[[0,0,0],[0,0,0],[0,0,0]] 看似没问题，当给某个元素赋值时如下：每个第一行每一列1的元素的值都改变了。12arr[1][1]=1;console.log(arr) // 输出结果为[[0,1,0],[0,1,0],[0,1,0]] 原因 fill()的参数不是基本类型时，好比数组、对象，并非将它的值填充到数组，而是将它的地址填充到数组，因此填充后数组的每一项都指向的是同一个对象，就会出现”牵一发而动全身”的现象。 解决方法可以使用map遍历123let arr=new Array(3).fill(0).map(item=&gt;new Array(3).fill(0))arr[1][1]=1console.log(arr); // 输出结果为[[0,0,0],[0,1,0],[0,0,0]] 这样就只有arr[1][1]发生改变了。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"forEach、for in 、 for of三者的区别","slug":"forEach,for in,for of三者区别","date":"2021-04-10T02:12:22.000Z","updated":"2021-04-10T03:43:51.996Z","comments":true,"path":"2021/04/10/forEach,for in,for of三者区别/","link":"","permalink":"http://xerduo.com/2021/04/10/forEach,for in,for of三者区别/","excerpt":"for循环除了这三种方法以外还有一种最原始的遍历，它用来遍历数组，for循环中可以使用return、break等来中断循环。","text":"for循环除了这三种方法以外还有一种最原始的遍历，它用来遍历数组，for循环中可以使用return、break等来中断循环。 123456789let arr = [1,2,3]for(let i = 0 ; i&lt; arr.length ; i++)&#123; console.log(arr[i])&#125;/* 输出结果123*/ forEach 对数组的每一个元素执行一次提供的函数（不能使用return、break等中断循环），不改变原数组，无返回值undefined。 123456789let arr = ['a', 'b', 'c']arr.forEach(function (val, index, arr) &#123; // val是当前元素，index当前元素索引，arr数组 console.log(val + ',' + index)&#125;)/* 输出结果a,0b,1c,2*/ for…in循环遍历的值都是数据结构的键值12345let obj = &#123;a: '1', b: '2', c: '3'&#125;for (let o in obj) &#123; console.log(o) //遍历的实际上是对象的属性名称 a,b,c console.log(obj[o]) //这个才是属性对应的值1，2，3&#125; for…in循环有几个缺点。 1、数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。2、for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。12345678910111213Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;;var arr = [3, 5];arr.foo = 'hello';for (var i in arr) &#123; console.log(i);&#125;// 结果是：// 0// 1// foo// arrCustom// objCustom 3、某些情况下，for…in循环会以任意顺序遍历键名。（先把当中的非负整数键提出来，排序好输出，然后将剩下的定义时的顺序输出）4、不可以使用return、break等来中断循环 总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。 for…ofES6中新增加的语法，用来循环获取一对键值对中的值，可以使用return、break等来中断循环 一个数据结构只有部署了 Symbol.iterator 属性, 才具有 iterator接口可以使用 for of循环。例子中的obj对象没有Symbol.iterator属性 所以会报错。 哪些数据结构部署了 Symbol.iteratoer属性了呢? 数组 ArrayMapSetStringarguments对象Nodelist对象, 就是获取的dom列表集合 循环一个数组1234let arr = ['China', 'America', 'Korea']for (let o of arr) &#123; console.log(o) //China, America, Korea&#125; 循环一个普通对象（报错） obj对象没有Symbol.iterator属性 所以会报错。 1234let obj = &#123;a: '1', b: '2', c: '3', d: '4'&#125;for (let o of obj) &#123; console.log(o) // Uncaught TypeError: obj is not iterabl&#125; 如果想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象的 key值集合后,再使用 for of，或者使用内置的Object.values()方法获取对象的value值集合再使用for of。 123456789let obj = &#123;a: '1', b: '2', c: '3', d: '4'&#125;for (let o of Object.keys(obj)) &#123; console.log(o) // a,b,c,d&#125;let obj = &#123;a: '1', b: '2', c: '3', d: '4'&#125;for (let o of Object.values(obj)) &#123; console.log(o) // 1,2,3,4&#125; 循环一个字符串 1234let str = 'love'for (let o of str) &#123; console.log(o) // l,o,v,e&#125; 循环一个Map123456789101112131415let iterable = new Map([[\"a\", 1], [\"b\", 2], [\"c\", 3]]);for (let [key, value] of iterable) &#123; console.log(value);&#125;// 1// 2// 3for (let entry of iterable) &#123; console.log(entry);&#125;// [a, 1]// [b, 2]// [c, 3] 循环一个Set12345678let iterable = new Set([1, 1, 2, 2, 3, 3]);for (let value of iterable) &#123; console.log(value);&#125;// 1// 2// 3","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"函数参数是按值传递的","slug":"函数参数是按值传递的","date":"2021-04-01T14:43:22.000Z","updated":"2021-04-01T14:53:24.298Z","comments":true,"path":"2021/04/01/函数参数是按值传递的/","link":"","permalink":"http://xerduo.com/2021/04/01/函数参数是按值传递的/","excerpt":"函数参数是按值传递的ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。","text":"函数参数是按值传递的ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用 ECMAScript 的话说，就是 arguments 对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。（这在 ECMAScript 中是不可能的。）来看下面这个例子： 12345678 function addTen(num) &#123; num += 10; return num; &#125; let count = 20;let result = addTen(count); console.log(count); // 20，没有变化console.log(result); // 30 这里，函数 addTen()有一个参数 num，它其实是一个局部变量。在调用时，变量 count 作为参数传入。count 的值是 20，这个值被复制到参数 num 以便在 addTen()内部使用。在函数内部，参数 num的值被加上了 10，但这不会影响函数外部的原始变量 count。参数 num 和变量 count 互不干扰，它们只不过碰巧保存了一样的值。如果 num 是按引用传递的，那么 count 的值也会被修改为 30。这个事实在使用数值这样的原始值时是非常明显的。但是，如果变量中传递的是对象，就没那么清楚了。比如，再看这个例子： 123456function setName(obj) &#123; obj.name = \"Nicholas\"; &#125; let person = new Object(); setName(person); console.log(person.name); // \"Nicholas\" 这一次，我们创建了一个对象并把它保存在变量 person 中。然后，这个对象被传给 setName()方法，并被复制到参数 obj 中。在函数内部，obj 和 person 都指向同一个对象。结果就是，即使对象是按值传进函数的，obj 也会通过引用访问对象。当函数内部给 obj 设置了 name 属性时，函数外部的对象也会反映这个变化，因为 obj 指向的对象保存在全局作用域的堆内存上。很多开发者错误地认为，当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子：12345678function setName(obj) &#123; obj.name = \"Nicholas\"; obj = new Object(); obj.name = \"Greg\"; &#125; let person = new Object(); setName(person); console.log(person.name); // \"Nicholas\" 这个例子前后唯一的变化就是 setName()中多了两行代码，将 obj 重新定义为一个有着不同 name的新对象。当 person 传入 setName()时，其 name 属性被设置为”Nicholas”。然后变量 obj 被设置为一个新对象且 name 属性被设置为”Greg”。如果 person 是按引用传递的，那么 person 应该自动将指针改为指向 name 为”Greg”的对象。可是，当我们再次访问 person.name 时，它的值是”Nicholas”，这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。 注意 ECMAScript 中函数的参数就是局部变量。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"前端页面自动渲染AE动画方案","slug":"前端页面自动渲染AE动画方案","date":"2021-03-10T07:57:22.000Z","updated":"2021-03-10T08:38:19.842Z","comments":true,"path":"2021/03/10/前端页面自动渲染AE动画方案/","link":"","permalink":"http://xerduo.com/2021/03/10/前端页面自动渲染AE动画方案/","excerpt":"前端页面自动渲染AE动画方案在项目中，登录页面设计师做了很酷炫的动画效果，开始我们想到的三种实现方式：1、导出GIF图给前端渲染2、导出视频给前端渲染3、导出动画的每一帧图片给前端序列合成动画后来这三种方式因显示效果不好，体积大或者实现复杂等原因被否定了。","text":"前端页面自动渲染AE动画方案在项目中，登录页面设计师做了很酷炫的动画效果，开始我们想到的三种实现方式：1、导出GIF图给前端渲染2、导出视频给前端渲染3、导出动画的每一帧图片给前端序列合成动画后来这三种方式因显示效果不好，体积大或者实现复杂等原因被否定了。 调研经调研发现 Lottie是可应用于Android, iOS, Web和Windows的库，通过Bodymovin解析AE动画，并导出可在移动端和web端渲染动画的json文件。换言之，设计师用AE把动画效果做出来，再用Bodymovin导出相应地json文件给到前端，前端使用Lottie库就可以实现动画效果，如下图: 设计师安装与使用Bodymovin1、关闭AE2、下载并安装ZXP installer https://aescripts.com/learn/zxp-installer/3、下载最新版bodymovin插件 https://github.com/airbnb/lottie-web/blob/master/build/extension/bodymovin.zxp4、把下载好的bodymovin.zxp拖到ZXP installer5、打开AE，在菜单首选项-&gt;常规中勾选☑️允许脚本写入文件和访问网络（否则输出JSON文件时会失败）6、在AE中制作动画，打开菜单窗口-&gt;拓展-&gt;Bodymovin，勾选要输出的动画，并设置输出文件目录，点击render打开输出目录会看到生成的JSON文件，若动画里导入了外部图片，则会在images中存放JSON中引用的图片 前端安装与使用lottie1、安装依赖 npm install lottie-web2、调用 lottie // 引入lottie import lottie from 'lottie-web'; /* */ // 使用 this.animation = lottie.loadAnimation({ container: this.$refs.loginContent, renderer: 'svg', loop: true, autoplay: true, animationData: loginJson, assetsPath: '/static/animation/login/', }); loadAnimation参数 参数 释义 container 用于渲染动画的HTML元素，需确保在调用loadAnimation时该元素已存在 renderer 渲染器，可选值为’svg’（默认值）/‘canvas’/‘html’。 loop 默认值为true。可传递需要循环的特定次数 autoplay 自动播放 path JSON文件路径 animationData JSON数据，与path互斥 name 传递该参数后，可在之后通过lottie命令引用该动画实例 rendererSettings 可传递给renderer实例的特定设置，具体可看 （renderer html的性能更好且支持3d图层） 调试由于创建Lottie动画和平常制作AE动画有所不同，设计师和前端之间有个动画效果联调的过程，为了提高联调效率，设计师可先进行初步的效果预览，再把文件交付给前端。 预览方法1、渲染前设置所要渲染的文件 2、勾选☑️Demo选项 在输出的文件目录中就可找到可预览的html文件 设计师注意事项 对设计师而言，创建Lottie动画和往常制作AE动画有所不同，此文档 (https://airbnb.io/lottie/#/supported-features) 记录了Bodymovin支持输出的AE功能列表，动画制作前需跟设计师沟通好，根据动画加载平台来确认可使用的AE功能。 除此之外，尽量遵循官方文档里对设计过程的指导和建议：1、动画简单化。 创建动画时需时刻记着保持JSON文件的精简，比如尽可能地绑定父子关系，在相似的图层上复制相同的关键帧会增加额外的代码，尽量不使用占用空间最多的路径关键帧动画。诸如自动跟踪描绘、颤动之类的技术会使得JSON文件变得非常大且耗性能。 2、建立形状图层。将AI、EPS、SVG和PDF等资源转换成形状图层否则无法在Lottie中正常使用，转换好后注意删除该资源以防被导出到JSON文件。 3、设置尺寸。在AE中可设置合成尺寸为任意大小，但需确保导出时合成尺寸和资源尺寸大小保持一致。 4、不使用表达式和特效。Lottie暂不支持。 5、注意遮罩尺寸。若使用alpha遮罩，遮照的大小会对性能产生很大的影响。尽可能地把遮罩尺寸维持到最小。 6、动画调试。若输出动画破损，通过每次导出特定图层来调试出哪些图层出了问题。然后在github中附上该图层文件提交问题，选择用其他方式重构该图层。 7、不使用混合模式和亮度蒙版。 8、不添加图层样式。 9、全屏动画。设置比想要支持的最宽屏幕更宽的导出尺寸。 10、设置空白对象。若使用空白对象，需确保勾选可见并设置透明度为0%否则不会被导出到JSON文件。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"Windows结束某个端口的进程","slug":"Windows结束某个端口的进程","date":"2021-03-08T13:04:12.000Z","updated":"2021-03-08T13:22:56.250Z","comments":true,"path":"2021/03/08/Windows结束某个端口的进程/","link":"","permalink":"http://xerduo.com/2021/03/08/Windows结束某个端口的进程/","excerpt":"Windows结束某个端口的进程以8080端口号为例1.打开cmd命令窗口，输入命令：1netstat -ano | findstr 8080 根据端口号查找对应的PID。发现8080端口被PID（进程号）为2188的进程占用。","text":"Windows结束某个端口的进程以8080端口号为例1.打开cmd命令窗口，输入命令：1netstat -ano | findstr 8080 根据端口号查找对应的PID。发现8080端口被PID（进程号）为2188的进程占用。2.根据PID找进程名称，输入命令：1tasklist | findstr 2181 发现是占用8080端口的进程为：javaw.exe。 3.根据PID结束对应进程。输入命令：1taskkill -PID 2188 -F 强制关闭PID为2188的进程。","categories":[{"name":"Windows","slug":"Windows","permalink":"http://xerduo.com/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://xerduo.com/tags/Windows/"}]},{"title":"JS类型检测","slug":"js类型检测","date":"2021-03-08T08:51:08.000Z","updated":"2021-03-08T13:17:41.620Z","comments":true,"path":"2021/03/08/js类型检测/","link":"","permalink":"http://xerduo.com/2021/03/08/js类型检测/","excerpt":"JS类型检测在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示： 基本类型：String、Number、Boolean、Symbol、Undefined、Null引用类型：Object 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。 鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，不同的方法得到的结果参差不齐。 下面介绍常用的4种方法，并对各个方法存在的问题进行简单的分析。","text":"JS类型检测在 ECMAScript 规范中，共定义了 7 种数据类型，分为 基本类型 和 引用类型 两大类，如下所示： 基本类型：String、Number、Boolean、Symbol、Undefined、Null引用类型：Object 基本类型也称为简单类型，由于其占据空间固定，是简单的数据段，为了便于提升变量查询速度，将其存储在栈中，即按值访问。 引用类型也称为复杂类型，由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度，因此，其值存储在堆(heap)中，而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。引用类型除 Object 外，还包括 Function 、Array、RegExp、Date 等等。 鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，不同的方法得到的结果参差不齐。 下面介绍常用的4种方法，并对各个方法存在的问题进行简单的分析。 typeof 1234567891011console.log(typeof \"\"); // string 有效console.log(typeof 1); // number 有效console.log(typeof Symbol()); // symbol 有效console.log(typeof true); // boolean 有效console.log(typeof undefined); // undefined 有效console.log(typeof null); // object 有效console.log(typeof []); // object 有效console.log(typeof function()&#123;&#125;); // function 有效console.log(typeof &#123;&#125;); // objectconsole.log(typeof new Date()); // objectconsole.log(typeof new RegExp()); // object 有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值： 对于基本类型，除 null 以外，均可以返回正确的结果。 对于引用类型，除 function 以外，一律返回 object 类型。 对于 null ，返回 object 类型。 对于 function 返回 function 类型。其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。 instanceofinstanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，我们用一段伪代码来模拟其内部执行过程： constructorObject.prototype.toString.call()toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。 12345678910111213Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ;// [object Boolean]Object.prototype.toString.call(Symbol());//[object Symbol]Object.prototype.toString.call(undefined) ;// [object Undefined]Object.prototype.toString.call(null) ;// [object Null]Object.prototype.toString.call(newFunction()) ;// [object Function]Object.prototype.toString.call(newDate()) ;// [object Date]Object.prototype.toString.call([]) ;// [object Array]Object.prototype.toString.call(newRegExp()) ;// [object RegExp]Object.prototype.toString.call(newError()) ;// [object Error]Object.prototype.toString.call(document) ;// [object HTMLDocument]Object.prototype.toString.call(window) ;//[object global] window 是全局对象 global 的引用","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"null与undefined","slug":"null与undefined","date":"2021-03-08T02:50:11.000Z","updated":"2021-04-01T15:06:02.818Z","comments":true,"path":"2021/03/08/null与undefined/","link":"","permalink":"http://xerduo.com/2021/03/08/null与undefined/","excerpt":"undefined与null ECMAScript 的原始类型中，是有Undefined 和 Null 类型的。 这两种类型都分别对应了属于自己的唯一专用值，即undefined 和 null。 ECMAScript 有 6 种简单数据类型（也称为原始类型）： Undefined、Null、Boolean、Number、String 和 Symbol 。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。","text":"undefined与null ECMAScript 的原始类型中，是有Undefined 和 Null 类型的。 这两种类型都分别对应了属于自己的唯一专用值，即undefined 和 null。 ECMAScript 有 6 种简单数据类型（也称为原始类型）： Undefined、Null、Boolean、Number、String 和 Symbol 。Symbol（符号）是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义（1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined 主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为 了正式明确空对象指针（null）和未初始化变量的区别。 null Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回”object”的原因：let car = null;console.log(typeof car); // “object”在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用 （1）在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。 // （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。Object.getPrototypeOf(Object.prototype)// null 检测1、可以使用 String()转型函数，它始终会返回表示相应类型值的字符串12String(null) // &apos;null&apos; ,String(undefined) // &apos;undefined&apos; 2、使用 Object.prototype.toString.call(arg)12Object.prototype.toString.call(undefined) ; // &quot;[object Undefined]&quot;Object.prototype.toString.call(null) ; // &quot;[object Null]&quot; 历史原因1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0。 1234Number(null)// 05 + null// 5 但是，JavaScript的设计者Brendan Eich（布兰登·艾克），觉得这样做还不够，有两个原因。 首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象。 其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。 因此，Brendan Eich又设计了一个undefined。","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xerduo.com/tags/JavaScript/"}]},{"title":"🎮基于canvas的俄罗斯方块游戏","slug":"基于canvas的俄罗斯方块游戏","date":"2021-01-03T07:00:53.000Z","updated":"2021-03-05T13:58:59.924Z","comments":true,"path":"2021/01/03/基于canvas的俄罗斯方块游戏/","link":"","permalink":"http://xerduo.com/2021/01/03/基于canvas的俄罗斯方块游戏/","excerpt":"演示地址 点击这里 使用方法 12// html部分&lt;div id=\"tetris\"&gt;&lt;/div&gt; 1234// Js部分 var tetris = new Tetris(&#123; id:\"tetris\"&#125;);","text":"演示地址 点击这里 使用方法 12// html部分&lt;div id=\"tetris\"&gt;&lt;/div&gt; 1234// Js部分 var tetris = new Tetris(&#123; id:\"tetris\"&#125;); 界面预览游戏开始 游戏进行中 游戏结束","categories":[{"name":"前端","slug":"前端","permalink":"http://xerduo.com/categories/前端/"}],"tags":[{"name":"游戏","slug":"游戏","permalink":"http://xerduo.com/tags/游戏/"}]}]}